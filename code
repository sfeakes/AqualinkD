aq_programmer.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
aq_programmer.c:  if (aq_data->active_thread.thread_id != 0) {
aq_programmer.c:    pthread_cond_broadcast(&aq_data->active_thread.thread_cond);
aq_programmer.c:  programmingthread->aq_data = aq_data;
aq_programmer.c:  //programmingthread->thread_args = args;
aq_programmer.c:    strncpy(programmingthread->thread_args, args, sizeof(programmingthread->thread_args)-1);
aq_programmer.c:      if(aq_data->active_thread.thread_id == 0) { // No need to thread a plane send if no active threads
aq_programmer.c:      } else if( pthread_create( &programmingthread->thread_id , NULL ,  threadded_send_cmd, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  get_aqualink_pool_spa_heater_temps, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  get_freeze_protect_temp, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  set_aqualink_time, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  set_aqualink_pool_heater_temps, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  set_aqualink_spa_heater_temps, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  set_aqualink_freeze_heater_temps, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  get_aqualink_diag_model, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  get_aqualink_programs, (void*)programmingthread) < 0) {
aq_programmer.c:      if( pthread_create( &programmingthread->thread_id , NULL ,  set_aqualink_light_colormode, (void*)programmingthread) < 0) {
aq_programmer.c:  pthread_detach(programmingthread->thread_id);
aq_programmer.c:  while ( (threadCtrl->aq_data->active_thread.thread_id != 0) && ( i++ <= tries) ) {
aq_programmer.c:    logMessage (LOG_DEBUG, "Thread %d sleeping, waiting for thread %d to finish\n", threadCtrl->thread_id, threadCtrl->aq_data->active_thread.thread_id);
aq_programmer.c:    logMessage (LOG_ERR, "Thread %d timeout waiting, ending\n",threadCtrl->thread_id);
aq_programmer.c:  threadCtrl->aq_data->active_thread.thread_id = &threadCtrl->thread_id;
aq_programmer.c:  threadCtrl->aq_data->active_thread.ptype = type;
aq_programmer.c:  logMessage (LOG_DEBUG, "Thread %d is active\n", threadCtrl->aq_data->active_thread.thread_id);
aq_programmer.c:  logMessage(LOG_DEBUG, "Thread %d finished\n",threadCtrl->thread_id);
aq_programmer.c:  threadCtrl->aq_data->active_thread.thread_id = 0;
aq_programmer.c:  threadCtrl->aq_data->active_thread.ptype = AQP_NULL;
aq_programmer.c:  threadCtrl->thread_id = 0;
aq_programmer.c:    sscanf(aq_data->last_message, "%s %d%s", leading, &current_val, trailing);
aq_programmer.c:      sprintf(searchBuf, "%s %d", value_label, current_val-1);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  send_cmd( (unsigned char)*threadCtrl->thread_args, aq_data);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  char *buf = (char*)threadCtrl->thread_args;
aq_programmer.c:  aqkey *button = &aq_data->aqbuttons[btn];
aq_programmer.c:  unsigned char code = button->code;
aq_programmer.c:  logMessage(LOG_NOTICE, "Pool Light Programming #: %d, on button: %s, with mode: %f\n", val, button->label, pmode);
aq_programmer.c:    if ( button->led->state == ON ) {
aq_programmer.c:  if ( button->led->state != ON ) {
aq_programmer.c:      logMessage(LOG_INFO, "Pool Light button press number %d - %s of %d\n", i, i % 2 == 0 ? "Off" : "On", val);
aq_programmer.c:      logMessage(LOG_INFO, "Pool Light button press number %d - %s of %d\n", i, "ON", val);
aq_programmer.c:      logMessage(LOG_INFO, "Pool Light button press number %d - %s of %d\n", i, "OFF", val);
aq_programmer.c:    logMessage(LOG_INFO, "Pool Light button press number %d - %s of %d\n", i, "ON", val);
aq_programmer.c:  //waitForButtonState(aq_data, &aq_data->aqbuttons[btn], ON, 2);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  int val = atoi((char*)threadCtrl->thread_args);
aq_programmer.c:  waitForMessage(threadCtrl->aq_data, "POOL TEMP IS SET TO", 1); 
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  int val = atoi((char*)threadCtrl->thread_args);
aq_programmer.c:  waitForMessage(threadCtrl->aq_data, "SPA TEMP IS SET TO", 1);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  int val = atoi((char*)threadCtrl->thread_args);
aq_programmer.c:  waitForMessage(threadCtrl->aq_data, "FREEZE PROTECTION IS SET TO", 3);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  if (result->tm_hour == 0)
aq_programmer.c:  else if (result->tm_hour < 11)
aq_programmer.c:    sprintf(hour, "HOUR %d AM", result->tm_hour);
aq_programmer.c:  else if (result->tm_hour == 12)
aq_programmer.c:    sprintf(hour, "HOUR %d PM", result->tm_hour - 12);
aq_programmer.c:  logMessage(LOG_DEBUG, "Setting time to %d/%d/%d %d:%d\n", result->tm_mon + 1, result->tm_mday, result->tm_year + 1900, result->tm_hour + 1, result->tm_min);
aq_programmer.c:  setAqualinkNumericField(aq_data, "YEAR", result->tm_year + 1900);
aq_programmer.c:  setAqualinkNumericField(aq_data, "MONTH", result->tm_mon + 1);
aq_programmer.c:  setAqualinkNumericField(aq_data, "DAY", result->tm_mday);
aq_programmer.c:  setAqualinkNumericField(aq_data, "MINUTE", result->tm_min);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  //8157 REV MMM | BATTERY OK | Cal:  -27  0  6 | CONTROL PANEL #1 | CONTROL PANEL #3 | WATER SENSOR OK | AIR SENSOR OK | SOLAR SENSOR OPENED
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  waitForMessage(threadCtrl->aq_data, "MAINTAIN TEMP IS", 5);
aq_programmer.c:  //cancel_menu(threadCtrl->aq_data);
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  struct aqualinkdata *aq_data = threadCtrl->aq_data;
aq_programmer.c:  while ( (aq_data->aq_command != NUL) && ( i++ < 10) ) {
aq_programmer.c:  aq_data->aq_command = cmd;
aq_programmer.c:  logMessage(LOG_DEBUG, "Sent '0x%02hhx' to controller\n", aq_data->aq_command);
aq_programmer.c:  pthread_mutex_init(&aq_data->active_thread.thread_mutex, NULL);
aq_programmer.c:  pthread_mutex_lock(&aq_data->active_thread.thread_mutex);
aq_programmer.c:    logMessage(LOG_DEBUG, "Programming mode: loop %d of %d looking for '%s' OR '%s' received message1 '%s'\n",i,numMessageReceived,message1,message2,aq_data->last_message);
aq_programmer.c:      ptr = strstr(aq_data->last_message, msgS1);
aq_programmer.c:        else if (ptr == aq_data->last_message) // match & do care if first char
aq_programmer.c:      ptr = strstr(aq_data->last_message, msgS2);
aq_programmer.c:        else if (ptr == aq_data->last_message) // match & do care if first char
aq_programmer.c:    //logMessage(LOG_DEBUG, "Programming mode: looking for '%s' received message1 '%s'\n",message1,aq_data->last_message);
aq_programmer.c:    pthread_cond_init(&aq_data->active_thread.thread_cond, NULL);
aq_programmer.c:    pthread_cond_wait(&aq_data->active_thread.thread_cond, &aq_data->active_thread.thread_mutex);
aq_programmer.c:    //logMessage(LOG_DEBUG, "Programming mode: loop %d of %d looking for '%s' received message1 '%s'\n",i,numMessageReceived,message1,aq_data->last_message);
aq_programmer.c:  pthread_mutex_unlock(&aq_data->active_thread.thread_mutex);
aq_programmer.c:  logMessage(LOG_DEBUG, "Programming mode: found message1 '%s' or '%s' in '%s'\n",message1,message2,aq_data->last_message);
aq_programmer.c:  pthread_mutex_init(&aq_data->active_thread.thread_mutex, NULL);
aq_programmer.c:  pthread_mutex_lock(&aq_data->active_thread.thread_mutex);
aq_programmer.c:    logMessage(LOG_DEBUG, "Programming mode: loop %d of %d looking for '%s' received message '%s'\n",i,numMessageReceived,message,aq_data->last_message);
aq_programmer.c:      ptr = strstr(aq_data->last_message, msgS);
aq_programmer.c:        else if (ptr == aq_data->last_message) // match & do care if first char
aq_programmer.c:    //logMessage(LOG_DEBUG, "Programming mode: looking for '%s' received message '%s'\n",message,aq_data->last_message);
aq_programmer.c:    pthread_cond_init(&aq_data->active_thread.thread_cond, NULL);
aq_programmer.c:    pthread_cond_wait(&aq_data->active_thread.thread_cond, &aq_data->active_thread.thread_mutex);
aq_programmer.c:    //logMessage(LOG_DEBUG, "Programming mode: loop %d of %d looking for '%s' received message '%s'\n",i,numMessageReceived,message,aq_data->last_message);
aq_programmer.c:  pthread_mutex_unlock(&aq_data->active_thread.thread_mutex);
aq_programmer.c:  logMessage(LOG_DEBUG, "Programming mode: found message '%s' in '%s'\n",message,aq_data->last_message);
aq_programmer.c:  while( (strstr(aq_data->last_message, item_string) == NULL) && ( i++ < wait_messages) )
aq_programmer.c:    logMessage(LOG_DEBUG, "Find item in Menu: loop %d of %d looking for '%s' received message '%s'\n",i,wait_messages,item_string,aq_data->last_message);
aq_programmer.c:  if (strstr(aq_data->last_message, item_string) == NULL) {
aq_programmer.c:  pthread_mutex_init(&aq_data->active_thread.thread_mutex, NULL);
aq_programmer.c:  pthread_mutex_lock(&aq_data->active_thread.thread_mutex);
aq_programmer.c:    logMessage(LOG_DEBUG, "Programming mode: loop %d of %d looking for state change to '%d' for '%s' \n",i,numMessageReceived,button->led->state,button->name);
aq_programmer.c:    if (button->led->state == state) {
aq_programmer.c:    //logMessage(LOG_DEBUG, "Programming mode: looking for '%s' received message '%s'\n",message,aq_data->last_message);
aq_programmer.c:    pthread_cond_init(&aq_data->active_thread.thread_cond, NULL);
aq_programmer.c:    pthread_cond_wait(&aq_data->active_thread.thread_cond, &aq_data->active_thread.thread_mutex);
aq_programmer.c:    //logMessage(LOG_DEBUG, "Programming mode: loop %d of %d looking for '%s' received message '%s'\n",i,numMessageReceived,message,aq_data->last_message);
aq_programmer.c:  pthread_mutex_unlock(&aq_data->active_thread.thread_mutex);
aq_programmer.c:    logMessage(LOG_DEBUG, "Programming mode: did not find state '%d' for '%s'\n",button->led->state,button->name);
aq_programmer.c:  logMessage(LOG_DEBUG, "Programming mode: found state '%d' for '%s'\n",button->led->state,button->name);
aq_programmer.h:  AQP_NULL = -1,
Binary file aq_programmer.o matches
aq_serial.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
aq_serial.c:    return -1;
aq_serial.c:  n = length - 3;
aq_serial.c:  ackPacket[7] = generate_checksum(ackPacket, length-1);
aq_serial.c:  ackPacket[7] = generate_checksum(ackPacket, length-1);
aq_serial.c:    ackPacket[7] = generate_checksum(ackPacket, length-1);
aq_serial.c:    nwrite = write(fd, ackPacket + i, length - i);
aq_serial.c:        index--;
aq_serial.c:        index--;
aq_serial.c:      logMessage(LOG_WARNING, "Read error: %d - %s\n", errno, strerror(errno));
aq_serial.c:        // Return a -1.
aq_serial.c:        return -1;
Binary file aq_serial.o matches
aqualinkd.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
aqualinkd.c:  if ( _aqualink_data.aqualinkleds[POOL_HTR_LED_INDEX-1].state == OFF && _aqualink_data.aqualinkleds[POOL_HTR_LED_INDEX].state == ON)
aqualinkd.c:  _aqualink_data.aqualinkleds[POOL_HTR_LED_INDEX-1].state = ENABLE;\
aqualinkd.c:  if ( _aqualink_data.aqualinkleds[SPA_HTR_LED_INDEX-1].state == OFF && _aqualink_data.aqualinkleds[SPA_HTR_LED_INDEX].state == ON)
aqualinkd.c:  _aqualink_data.aqualinkleds[SPA_HTR_LED_INDEX-1].state = ENABLE;
aqualinkd.c:  if ( _aqualink_data.aqualinkleds[SOLAR_HTR_LED_INDEX-1].state == OFF && _aqualink_data.aqualinkleds[SOLAR_HTR_LED_INDEX].state == ON)
aqualinkd.c:  _aqualink_data.aqualinkleds[SOLAR_HTR_LED_INDEX-1].state = ENABLE;
aqualinkd.c:    logMessage(LOG_DEBUG, "time not checked, will check in %d seconds", TIME_CHECK_INTERVAL - time_difference);
aqualinkd.c:  aq_tm.tm_isdst = -1;  // Force mktime to use local timezone
aqualinkd.c:  logMessage(LOG_DEBUG, "RS Message :- '%s'\n",msg);
aqualinkd.c:    if (msg[strlen(msg)-1] == 'F')
aqualinkd.c:    else if (msg[strlen(msg)-1] == 'C')
aqualinkd.c:  else if( (msg[1] == ':' || msg[2] == ':') && msg[strlen(msg)-1] == 'M') { // time in format '9:45 AM'
aqualinkd.c:    if (_aqualink_data.aqbuttons[PUMP_INDEX].led->state == OFF ) {
aqualinkd.c:    } else if (_aqualink_data.aqbuttons[SPA_INDEX].led->state == OFF ) {
aqualinkd.c:    } else if (_aqualink_data.aqbuttons[SPA_INDEX].led->state == ON ) {
aqualinkd.c:    if (strcmp(argv[i], "-d") == 0) {
aqualinkd.c:    } else if (strcmp(argv[i], "-c") == 0) {
aqualinkd.c:  // logMessage (LOG_NOTICE, "Config serial_port = %s\n", config_parameters->serial_port);
aqualinkd.c:    logMessage(LOG_NOTICE, "Config BTN %-13s = label %-15s | dzidx %d\n", _aqualink_data.aqbuttons[i].name, _aqualink_data.aqbuttons[i].label , _aqualink_data.aqbuttons[i].dz_idx);
aqualinkd.c:    if (packet_length == -1) {
Binary file aqualinkd.o matches
aqualinkd.test.conf:# 08-0b, 10-13, 18-1b, 20-23,
aqualink.h:#define TEMP_UNKNOWN    -999
config.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
config.c:  parms->serial_port = DEFAULT_SERIALPORT;
config.c:  parms->log_level = DEFAULT_LOG_LEVEL;
config.c:  parms->socket_port = DEFAULT_WEBPORT;
config.c:  parms->web_directory = DEFAULT_WEBROOT;
config.c:  //parms->device_id = strtoul(DEFAULT_DEVICE_ID, &p, 16);
config.c:  parms->device_id = strtoul(DEFAULT_DEVICE_ID, NULL, 16);
config.c:  //sscanf(DEFAULT_DEVICE_ID, "0x%x", &parms->device_id);
config.c:  parms->mqtt_dz_sub_topic = DEFAULT_MQTT_DZ_OUT;
config.c:  parms->mqtt_dz_pub_topic = DEFAULT_MQTT_DZ_IN;
config.c:  parms->mqtt_aq_topic = DEFAULT_MQTT_AQ_TP;
config.c:  parms->mqtt_server = DEFAULT_MQTT_SERVER;
config.c:  parms->mqtt_user = DEFAULT_MQTT_USER;
config.c:  parms->mqtt_passwd = DEFAULT_MQTT_PASSWD;
config.c:  parms->dzidx_air_temp = TEMP_UNKNOWN;
config.c:  parms->dzidx_pool_water_temp = TEMP_UNKNOWN;
config.c:  parms->dzidx_spa_water_temp = TEMP_UNKNOWN;
config.c:  //parms->dzidx_pool_thermostat = TEMP_UNKNOWN; // removed until domoticz has a better virtual thermostat
config.c:  //parms->dzidx_spa_thermostat = TEMP_UNKNOWN; // removed until domoticz has a better virtual thermostat
config.c:  parms->light_programming_mode = 0;
config.c:  parms->deamonize = true;
config.c:  parms->log_file = '\0';
config.c:  generate_mqtt_id(parms->mqtt_ID, MQTT_ID_LEN);
config.c:  loc2--;
config.c:  while(isspace(str[loc2])) loc2--;
config.c:  result = (char*)malloc(loc2-loc1+2*sizeof(char));
config.c:  strncpy ( result, &str[loc1], loc2-loc1+1 );
config.c:  result[loc2-loc1+1] = '\0';
config.c:    for (intf = if_nidxs; intf->if_index != 0 || intf->if_name != NULL; intf++)
config.c:      strcpy(s.ifr_name, intf->if_name);
config.c:    if (!mac(&buf[i], len - i)) {
config.c:      sprintf(&buf[i], "%.*d", (len-i), getpid());
config.c:              //config_parameters->socket_port = cleanint(indx+1);
config.c:              config_parameters->socket_port = cleanalloc(indx+1);
config.c:              config_parameters->serial_port = cleanalloc(indx+1);
config.c:              config_parameters->log_level = text2elevel(cleanalloc(indx+1));
config.c:              config_parameters->device_id = strtoul(cleanalloc(indx+1), NULL, 16);
config.c:              config_parameters->web_directory = cleanalloc(indx+1);
config.c:              config_parameters->log_file = cleanalloc(indx+1);
config.c:              config_parameters->mqtt_server = cleanalloc(indx+1);
config.c:              config_parameters->mqtt_dz_sub_topic = cleanalloc(indx+1);
config.c:              config_parameters->mqtt_dz_pub_topic = cleanalloc(indx+1);
config.c:              config_parameters->mqtt_aq_topic = cleanalloc(indx+1);
config.c:              config_parameters->mqtt_user = cleanalloc(indx+1);
config.c:              config_parameters->mqtt_passwd = cleanalloc(indx+1);
config.c:              config_parameters->dzidx_air_temp = strtoul(indx+1, NULL, 10);
config.c:              config_parameters->dzidx_pool_water_temp = strtoul(indx+1, NULL, 10);
config.c:              config_parameters->dzidx_spa_water_temp = strtoul(indx+1, NULL, 10);
config.c:              config_parameters->light_programming_mode = atof(cleanalloc(indx+1)); // should free this
config.c:              config_parameters->dzidx_pool_thermostat = strtoul(indx+1, NULL, 10);
config.c:              config_parameters->dzidx_spa_thermostat = strtoul(indx+1, NULL, 10);
config.c:              int num = strtoul(b_ptr+7, NULL, 10) - 1;
config.c:                aqdata->aqbuttons[num].label = cleanalloc(indx+1);
config.c:                aqdata->aqbuttons[num].dz_idx = strtoul(indx+1, NULL, 10);
Binary file config.o matches
init_buttons.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
init_buttons.c:  aqdata->aqbuttons[0].led = &aqdata->aqualinkleds[7-1];
init_buttons.c:  aqdata->aqbuttons[0].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[0].label = BTN_PUMP;
init_buttons.c:  //aqdata->aqbuttons[0].label = "Filter Pump";
init_buttons.c:  aqdata->aqbuttons[0].name = BTN_PUMP;
init_buttons.c:  //aqdata->aqbuttons[0].code = (unsigned char *)KEY_PUMP;
init_buttons.c:  aqdata->aqbuttons[0].code = KEY_PUMP;
init_buttons.c:  aqdata->aqbuttons[0].dz_idx = 37;
init_buttons.c:  aqdata->aqbuttons[1].led = &aqdata->aqualinkleds[6-1];
init_buttons.c:  aqdata->aqbuttons[1].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[1].label = BTN_SPA;
init_buttons.c:  //aqdata->aqbuttons[1].label = "Spa Mode";
init_buttons.c:  aqdata->aqbuttons[1].name = BTN_SPA;
init_buttons.c:  //aqdata->aqbuttons[1].code = (unsigned char *)KEY_SPA;
init_buttons.c:  aqdata->aqbuttons[1].code = KEY_SPA;
init_buttons.c:  aqdata->aqbuttons[1].dz_idx = 38;
init_buttons.c:  aqdata->aqbuttons[2].led = &aqdata->aqualinkleds[5-1];
init_buttons.c:  aqdata->aqbuttons[2].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[2].label = BTN_AUX1;
init_buttons.c:  //aqdata->aqbuttons[2].label = "Cleaner";
init_buttons.c:  aqdata->aqbuttons[2].name = BTN_AUX1;
init_buttons.c:  aqdata->aqbuttons[2].code = (unsigned char *)KEY_AUX1;
init_buttons.c:  aqdata->aqbuttons[2].dz_idx = 39;
init_buttons.c:  aqdata->aqbuttons[3].led = &aqdata->aqualinkleds[4-1];
init_buttons.c:  aqdata->aqbuttons[3].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[3].label = BTN_AUX2;
init_buttons.c:  //aqdata->aqbuttons[3].label = "Waterfall";
init_buttons.c:  aqdata->aqbuttons[3].name = BTN_AUX2;
init_buttons.c:  aqdata->aqbuttons[3].code = (unsigned char *)KEY_AUX2;
init_buttons.c:  aqdata->aqbuttons[3].dz_idx = 40;
init_buttons.c:  aqdata->aqbuttons[4].led = &aqdata->aqualinkleds[3-1];
init_buttons.c:  aqdata->aqbuttons[4].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[4].label = BTN_AUX3;
init_buttons.c:  //aqdata->aqbuttons[4].label = "Spa Blower";
init_buttons.c:  aqdata->aqbuttons[4].name = BTN_AUX3;
init_buttons.c:  aqdata->aqbuttons[4].code = (unsigned char *)KEY_AUX3;
init_buttons.c:  aqdata->aqbuttons[4].dz_idx = 41;
init_buttons.c:  aqdata->aqbuttons[5].led = &aqdata->aqualinkleds[9-1];
init_buttons.c:  aqdata->aqbuttons[5].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[5].label = BTN_AUX4;
init_buttons.c:  //aqdata->aqbuttons[5].label = "Pool Light";
init_buttons.c:  aqdata->aqbuttons[5].name = BTN_AUX4;
init_buttons.c:  aqdata->aqbuttons[5].code = (unsigned char *)KEY_AUX4;
init_buttons.c:  aqdata->aqbuttons[5].dz_idx = 42;
init_buttons.c:  aqdata->aqbuttons[6].led = &aqdata->aqualinkleds[8-1];
init_buttons.c:  aqdata->aqbuttons[6].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[6].label = BTN_AUX5;
init_buttons.c:  //aqdata->aqbuttons[6].label = "Spa Light";
init_buttons.c:  aqdata->aqbuttons[6].name = BTN_AUX5;
init_buttons.c:  aqdata->aqbuttons[6].code = (unsigned char *)KEY_AUX5;
init_buttons.c:  aqdata->aqbuttons[6].dz_idx = 43;
init_buttons.c:  aqdata->aqbuttons[7].led = &aqdata->aqualinkleds[12-1];
init_buttons.c:  aqdata->aqbuttons[7].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[7].label = BTN_AUX6;
init_buttons.c:  aqdata->aqbuttons[7].name = BTN_AUX6;
init_buttons.c:  aqdata->aqbuttons[7].code = (unsigned char *)KEY_AUX6;
init_buttons.c:  aqdata->aqbuttons[7].dz_idx = DZ_NULL_IDX;
init_buttons.c:  aqdata->aqbuttons[8].led = &aqdata->aqualinkleds[1-1];
init_buttons.c:  aqdata->aqbuttons[8].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[8].label = BTN_AUX7;
init_buttons.c:  aqdata->aqbuttons[8].name = BTN_AUX7;
init_buttons.c:  aqdata->aqbuttons[8].code = (unsigned char *)KEY_AUX7;
init_buttons.c:  aqdata->aqbuttons[8].dz_idx = DZ_NULL_IDX;
init_buttons.c:  aqdata->aqbuttons[9].led = &aqdata->aqualinkleds[15-1];
init_buttons.c:  aqdata->aqbuttons[9].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[9].label = BTN_POOL_HTR;
init_buttons.c:  //aqdata->aqbuttons[9].label = "Heater";
init_buttons.c:  aqdata->aqbuttons[9].name = BTN_POOL_HTR;
init_buttons.c:  aqdata->aqbuttons[9].code = (unsigned char *)KEY_POOL_HTR;
init_buttons.c:  aqdata->aqbuttons[9].dz_idx = 44;
init_buttons.c:  aqdata->aqbuttons[10].led = &aqdata->aqualinkleds[17-1];
init_buttons.c:  aqdata->aqbuttons[10].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[10].label = BTN_SPA_HTR;
init_buttons.c:  //aqdata->aqbuttons[10].label = "Heater";
init_buttons.c:  aqdata->aqbuttons[10].name = BTN_SPA_HTR;
init_buttons.c:  aqdata->aqbuttons[10].code = (unsigned char *)KEY_SPA_HTR;
init_buttons.c:  aqdata->aqbuttons[10].dz_idx = 44;
init_buttons.c:  aqdata->aqbuttons[11].led = &aqdata->aqualinkleds[19-1];
init_buttons.c:  aqdata->aqbuttons[11].led->state = LED_S_UNKNOWN;
init_buttons.c:  aqdata->aqbuttons[11].label = BTN_SOLAR_HTR;
init_buttons.c:  //aqdata->aqbuttons[11].label = "Solar Heater";
init_buttons.c:  aqdata->aqbuttons[11].name = BTN_SOLAR_HTR;
init_buttons.c:  aqdata->aqbuttons[11].code = (unsigned char *)KEY_SOLAR_HTR;
init_buttons.c:  aqdata->aqbuttons[11].dz_idx = DZ_NULL_IDX;
Binary file init_buttons.o matches
json_messages.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
json_messages.c:  if (aqdata->active_thread.thread_id != 0) {
json_messages.c:  if (aqdata->last_message != NULL && strstr(aqdata->last_message, "SERVICE") != NULL ) {
json_messages.c:  //length += sprintf(buffer+length, ",\"message\":\"%s\"",aqdata->message );
json_messages.c:  length += sprintf(buffer+length, ",\"version\":\"%s\"",aqdata->version );//8157 REV MMM",
json_messages.c:  length += sprintf(buffer+length, ",\"date\":\"%s\"",aqdata->date );//"09/01/16 THU",
json_messages.c:  length += sprintf(buffer+length, ",\"time\":\"%s\"",aqdata->time );//"1:16 PM",
json_messages.c:  //length += sprintf(buffer+length, ",\"air_temp\":\"%d\"",aqdata->air_temp );//"96",
json_messages.c:  //length += sprintf(buffer+length, ",\"pool_temp\":\"%d\"",aqdata->pool_temp );//"86",
json_messages.c:  //length += sprintf(buffer+length, ",\"spa_temp\":\"%d\"",aqdata->spa_temp );//" ",
json_messages.c:  length += sprintf(buffer+length, ",\"pool_htr_set_pnt\":\"%d\"",aqdata->pool_htr_set_point );//"85",
json_messages.c:  length += sprintf(buffer+length, ",\"spa_htr_set_pnt\":\"%d\"",aqdata->spa_htr_set_point );//"99",
json_messages.c:  //length += sprintf(buffer+length, ",\"freeze_protection":\"%s\"",aqdata->frz_protect_set_point );//"off",
json_messages.c:  length += sprintf(buffer+length, ",\"frz_protect_set_pnt\":\"%d\"",aqdata->frz_protect_set_point );//"0",
json_messages.c:  if ( aqdata->air_temp == TEMP_UNKNOWN )
json_messages.c:    length += sprintf(buffer+length, ",\"air_temp\":\"%d\"",aqdata->air_temp );
json_messages.c:  if ( aqdata->pool_temp == TEMP_UNKNOWN )
json_messages.c:    length += sprintf(buffer+length, ",\"pool_temp\":\"%d\"",aqdata->pool_temp );
json_messages.c:  if ( aqdata->spa_temp == TEMP_UNKNOWN )
json_messages.c:    length += sprintf(buffer+length, ",\"spa_temp\":\"%d\"",aqdata->spa_temp );
json_messages.c:  if ( aqdata->temp_units == FAHRENHEIT )
json_messages.c:  else if ( aqdata->temp_units == CELSIUS )
json_messages.c:  if (aqdata->battery == OK)
json_messages.c:    switch (aqdata->aqbuttons[i].led->state)
json_messages.c:    length += sprintf(buffer+length, "\"%s\": \"%s\"", aqdata->aqbuttons[i].name, state);
json_messages.c:  for (i=strlen(buffer); i > strlen(buffer)-10; i--) {
json_messages.c:  for (i=10; i >= 0; i--) {
json_messages.c:  //return length-1;
json_messages.c:  for (i=strlen(buffer2); i > strlen(buffer2)-10; i--) {
json_messages.c:  for (i=10; i >= 0; i--) {
json_messages.c:    length += sprintf(buffer+length, ",\"%s\": \"%s\"", aqdata->aqbuttons[i].name, aqdata->aqbuttons[i].label);
json_messages.c:  request->first.key    = NULL;
json_messages.c:  request->first.value  = NULL;
json_messages.c:  request->second.key   = NULL;
json_messages.c:  request->second.value = NULL;
json_messages.c: //printf (" <-  END");
json_messages.c://printf (" <-  START");
json_messages.c:          request->first.key = &buffer[i];
json_messages.c:          request->first.value = &buffer[i];
json_messages.c:          request->second.key = &buffer[i];
json_messages.c:          request->second.value = &buffer[i];
json_messages.c:            strncpy(svalue, &str[i], ((j-i)>DZ_SVALUE_LEN?DZ_SVALUE_LEN:(j-i)));
json_messages.c:            svalue[((j-i)>DZ_SVALUE_LEN?DZ_SVALUE_LEN:(j-i))] = '\0'; // Simply force the last termination
Binary file json_messages.o matches
Makefile:LIBS := -lpthread
Makefile:#LIBS := -lpthread -lwebsockets
Makefile:#$DBG = -g
Makefile:# define any compile-time flags
Makefile:#CFLAGS = -Wall -g -lpthread -lwiringPi -lm -I. 
Makefile:#CFLAGS = -Wall -g $(LIBS) -I/usr/local/include/ -L/usr/local/lib/
Makefile:#CFLAGS = -Wall -g $(LIBS) -std=gnu11 -I/nas/data/Development/Raspberry/aqualink/libwebsockets-2.0-stable/lib -L/nas/data/Development/Raspberry/aqualink/libwebsockets-2.0-stable/lib
Makefile:#CFLAGS = -Wall -g $(LIBS)
Makefile:#CFLAGS = -Wall -g $(LIBS) -std=gnu11
Makefile:CFLAGS = -Wall $(DBG) $(LIBS) -D MG_DISABLE_MD5 -D MG_DISABLE_HTTP_DIGEST_AUTH -D MG_DISABLE_MD5 -D MG_DISABLE_JSON_RPC
Makefile:#CFLAGS = -Wall $(DBG) $(LIBS) -D MG_DISABLE_MQTT -D MG_DISABLE_MD5 -D MG_DISABLE_HTTP_DIGEST_AUTH -D MG_DISABLE_MD5 -D MG_DISABLE_JSON_RPC
Makefile:	$(CC) $(CFLAGS) $(INCLUDES) -o $(MAIN) $(OBJS) $(LFLAGS) $(LIBS)
Makefile:	$(CC) $(CFLAGS) $(INCLUDES) -c $<  -o $@
Makefile:#	gcc -L/home/perry/workspace/libwebsockets/Debug -pg -o"aqualinkd" $(OBJS) $(USER_OBJS) $(LIBS)
Makefile:#	-$(RM) $(OBJS)$(C_DEPS)$(EXECUTABLES) aqualinkd
Makefile:#	-@echo ' '
Makefile:#-include ../makefile.targets
mongoose.c: * If chunks get reassembled, modify hm->body to point to the reassembled
mongoose.c: * in nc->flags, delete reassembled body from the mbuf.
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  LL_NONE = -1,
mongoose.c:  _LL_MIN = -2,
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  fprintf(cs_log_file, "%-20s ", prefix);
mongoose.c:    fprintf(cs_log_file, "%7u ", (unsigned int) ((now - cs_log_ts) * 1000000));
mongoose.c:#define NUM_UPPERCASES ('Z' - 'A' + 1)
mongoose.c:#define NUM_DIGITS ('9' - '0' + 1)
mongoose.c:    ctx->b64_putc(v + 'A', ctx->user_data);
mongoose.c:    ctx->b64_putc(v - NUM_UPPERCASES + 'a', ctx->user_data);
mongoose.c:    ctx->b64_putc(v - NUM_LETTERS + '0', ctx->user_data);
mongoose.c:    ctx->b64_putc(v - NUM_LETTERS - NUM_DIGITS == 0 ? '+' : '/',
mongoose.c:                  ctx->user_data);
mongoose.c:  a = ctx->chunk[0];
mongoose.c:  b = ctx->chunk[1];
mongoose.c:  c = ctx->chunk[2];
mongoose.c:  if (ctx->chunk_size > 1) {
mongoose.c:  if (ctx->chunk_size > 2) {
mongoose.c:  ctx->chunk_size = 0;
mongoose.c:  ctx->b64_putc = b64_putc;
mongoose.c:  ctx->user_data = user_data;
mongoose.c:    ctx->chunk[ctx->chunk_size++] = src[i];
mongoose.c:    if (ctx->chunk_size == 3) {
mongoose.c:      ctx->chunk_size = 0;
mongoose.c:  if (ctx->chunk_size > 0) {
mongoose.c:    memset(&ctx->chunk[ctx->chunk_size], 0, 3 - ctx->chunk_size);
mongoose.c:    for (i = 0; i < (3 - ctx->chunk_size); i++) {
mongoose.c:      ctx->b64_putc('=', ctx->user_data);
mongoose.c:/* Convert one byte of encoded base64 input stream to 6-bit chunk */
mongoose.c:    len -= 4;
mongoose.c:  if (dec_len != NULL) *dec_len = (dst - orig_dst);
mongoose.c:  return orig_len - len;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:      dir->handle = FindFirstFileW(wpath, &dir->info);
mongoose.c:      dir->result.d_name[0] = '\0';
mongoose.c:    if (dir->handle != INVALID_HANDLE_VALUE)
mongoose.c:      result = FindClose(dir->handle) ? 0 : -1;
mongoose.c:    result = -1;
mongoose.c:    memset(&dir->result, 0, sizeof(dir->result));
mongoose.c:    if (dir->handle != INVALID_HANDLE_VALUE) {
mongoose.c:      result = &dir->result;
mongoose.c:      (void) WideCharToMultiByte(CP_UTF8, 0, dir->info.cFileName, -1,
mongoose.c:                                 result->d_name, sizeof(result->d_name), NULL,
mongoose.c:      if (!FindNextFileW(dir->handle, &dir->info)) {
mongoose.c:        (void) FindClose(dir->handle);
mongoose.c:        dir->handle = INVALID_HANDLE_VALUE;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:   * 1. VC 6.0 doesn't support conversion uint64 -> double, so, using int64
mongoose.c:   * 2. Windows FILETIME is a number of 100-nanosecond intervals since January
mongoose.c:                  10000000.0) -
mongoose.c:  /* Month-to-day offset for non-leap-years. */
mongoose.c:  int month = tm->tm_mon % 12;
mongoose.c:  int year = tm->tm_year + tm->tm_mon / 12;
mongoose.c:    --year;
mongoose.c:      tm->tm_sec /* Seconds */
mongoose.c:          (tm->tm_min /* Minute = 60 seconds */
mongoose.c:           60 * (tm->tm_hour /* Hour = 60 minutes */
mongoose.c:                 24 * (month_day[month] + tm->tm_mday - 1 /* Day = 24 hours */
mongoose.c:                       + 365 * (year - 70)                /* Year = 365 days */
mongoose.c:                       + (year_for_leap - 69) / 4 /* Every 4 years is leap... */
mongoose.c:                       - (year_for_leap - 1) / 100 /* Except centuries... */
mongoose.c:  return rt < 0 ? -1 : (double) rt;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * clang with std=-c99 uses __LITTLE_ENDIAN, by default
mongoose.c: * while for ex, RTOS gcc - LITTLE_ENDIAN, by default
mongoose.c: * This code implements the MD5 message-digest algorithm.
mongoose.c: * will fill a supplied 16-byte array with the digest.
mongoose.c:  } while (--longs);
mongoose.c:  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)
mongoose.c:  ctx->buf[0] = 0x67452301;
mongoose.c:  ctx->buf[1] = 0xefcdab89;
mongoose.c:  ctx->buf[2] = 0x98badcfe;
mongoose.c:  ctx->buf[3] = 0x10325476;
mongoose.c:  ctx->bits[0] = 0;
mongoose.c:  ctx->bits[1] = 0;
mongoose.c:  t = ctx->bits[0];
mongoose.c:  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;
mongoose.c:  ctx->bits[1] += (uint32_t) len >> 29;
mongoose.c:    unsigned char *p = (unsigned char *) ctx->in + t;
mongoose.c:    t = 64 - t;
mongoose.c:    byteReverse(ctx->in, 16);
mongoose.c:    cs_md5_transform(ctx->buf, (uint32_t *) ctx->in);
mongoose.c:    len -= t;
mongoose.c:    memcpy(ctx->in, buf, 64);
mongoose.c:    byteReverse(ctx->in, 16);
mongoose.c:    cs_md5_transform(ctx->buf, (uint32_t *) ctx->in);
mongoose.c:    len -= 64;
mongoose.c:  memcpy(ctx->in, buf, len);
mongoose.c:  count = (ctx->bits[0] >> 3) & 0x3F;
mongoose.c:  p = ctx->in + count;
mongoose.c:  count = 64 - 1 - count;
mongoose.c:    byteReverse(ctx->in, 16);
mongoose.c:    cs_md5_transform(ctx->buf, (uint32_t *) ctx->in);
mongoose.c:    memset(ctx->in, 0, 56);
mongoose.c:    memset(p, 0, count - 8);
mongoose.c:  byteReverse(ctx->in, 14);
mongoose.c:  a = (uint32_t *) ctx->in;
mongoose.c:  a[14] = ctx->bits[0];
mongoose.c:  a[15] = ctx->bits[1];
mongoose.c:  cs_md5_transform(ctx->buf, (uint32_t *) ctx->in);
mongoose.c:  byteReverse((unsigned char *) ctx->buf, 4);
mongoose.c:  memcpy(digest, ctx->buf, 16);
mongoose.c:#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
mongoose.c:  block->l[i] =
mongoose.c:      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);
mongoose.c:  return block->l[i];
mongoose.c:  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \
mongoose.c:                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \
mongoose.c:  context->state[0] = 0x67452301;
mongoose.c:  context->state[1] = 0xEFCDAB89;
mongoose.c:  context->state[2] = 0x98BADCFE;
mongoose.c:  context->state[3] = 0x10325476;
mongoose.c:  context->state[4] = 0xC3D2E1F0;
mongoose.c:  context->count[0] = context->count[1] = 0;
mongoose.c:  j = context->count[0];
mongoose.c:  if ((context->count[0] += len << 3) < j) context->count[1]++;
mongoose.c:  context->count[1] += (len >> 29);
mongoose.c:    memcpy(&context->buffer[j], data, (i = 64 - j));
mongoose.c:    cs_sha1_transform(context->state, context->buffer);
mongoose.c:      cs_sha1_transform(context->state, &data[i]);
mongoose.c:  memcpy(&context->buffer[j], &data[i], len - i);
mongoose.c:    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>
mongoose.c:                                      ((3 - (i & 3)) * 8)) &
mongoose.c:  while ((context->count[0] & 504) != 448) {
mongoose.c:        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
mongoose.c:  mbuf->len = mbuf->size = 0;
mongoose.c:  mbuf->buf = NULL;
mongoose.c:  if (mbuf->buf != NULL) {
mongoose.c:    MBUF_FREE(mbuf->buf);
mongoose.c:  if (new_size > a->size || (new_size < a->size && new_size >= a->len)) {
mongoose.c:    char *buf = (char *) MBUF_REALLOC(a->buf, new_size);
mongoose.c:    a->buf = buf;
mongoose.c:    a->size = new_size;
mongoose.c:  mbuf_resize(mbuf, mbuf->len);
mongoose.c:  assert(a->len <= a->size);
mongoose.c:  assert(off <= a->len);
mongoose.c:  if (~(size_t) 0 - (size_t) a->buf < len) return 0;
mongoose.c:  if (a->len + len <= a->size) {
mongoose.c:    memmove(a->buf + off + len, a->buf + off, a->len - off);
mongoose.c:      memcpy(a->buf + off, buf, len);
mongoose.c:    a->len += len;
mongoose.c:    size_t new_size = (size_t)((a->len + len) * MBUF_SIZE_MULTIPLIER);
mongoose.c:    if ((p = (char *) MBUF_REALLOC(a->buf, new_size)) != NULL) {
mongoose.c:      a->buf = p;
mongoose.c:      memmove(a->buf + off + len, a->buf + off, a->len - off);
mongoose.c:      if (buf != NULL) memcpy(a->buf + off, buf, len);
mongoose.c:      a->len += len;
mongoose.c:      a->size = new_size;
mongoose.c:  return mbuf_insert(a, a->len, buf, len);
mongoose.c:  if (n > 0 && n <= mb->len) {
mongoose.c:    memmove(mb->buf, mb->buf + n, mb->len - n);
mongoose.c:    mb->len -= n;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  size_t n2 = strlen(str2), n1 = str1->len;
mongoose.c:  int r = strncmp(str1->p, str2, (n1 < n2) ? n1 : n2);
mongoose.c:    return n1 - n2;
mongoose.c:  size_t n2 = strlen(str2), n1 = str1->len;
mongoose.c:  int r = mg_ncasecmp(str1->p, str2, (n1 < n2) ? n1 : n2);
mongoose.c:    return n1 - n2;
mongoose.c:  return mg_strdup_common(s, 0 /* NUL-terminate */);
mongoose.c:  return mg_strdup_common(s, 1 /* NUL-terminate */);
mongoose.c:    if (str1.p[i] < str2.p[i]) return -1;
mongoose.c:  if (i < str2.len) return -1;
mongoose.c:  for (i = 0; i <= haystack.len - needle.len; i++) {
mongoose.c:    num = -num;
mongoose.c:  /* Print into temporary buffer - in reverse order */
mongoose.c:      tmp[k++] = 'a' + (rem - 10);
mongoose.c:    while (k < field_width && k < (int) sizeof(tmp) - 1) {
mongoose.c:    tmp[k++] = '-';
mongoose.c:  while (--k >= 0) {
mongoose.c:       *   zero or more flags (one of: # 0 - <space> + ')
mongoose.c:      /* Flags. only zero-pad flag is supported. */
mongoose.c:        field_width += *fmt++ - '0';
mongoose.c:            precision += *fmt++ - '0';
mongoose.c:        int pad = field_width - (precision >= 0 ? c_strnlen(s, precision) : 0);
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int), 10, flags,
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, long), 10, flags,
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, ssize_t), 10, flags,
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int64_t), 10, flags,
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned),
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned long),
mongoose.c:        i += c_itoa(buf + i, buf_size - i, va_arg(ap, size_t),
mongoose.c:        i += c_itoa(buf + i, buf_size - i, num, 16, flags, 0);
mongoose.c:  /* Zero-terminate the result */
mongoose.c:    buf[i < (int) buf_size ? i : (int) buf_size - 1] = '\0';
mongoose.c:  buf[sizeof(buf) - 1] = '\0';
mongoose.c:  p = buf + strlen(buf) - 1;
mongoose.c:  while (p > buf && p[-1] != ':' && (p[0] == '\\' || p[0] == '/')) *p-- = '\0';
mongoose.c:  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);
mongoose.c:   * Convert back to Unicode. If doubly-converted string does not match the
mongoose.c:  for (; len--; p++) {
mongoose.c:    return ch - '0';
mongoose.c:    return ch - 'a' + 10;
mongoose.c:    return ch - 'A' + 10;
mongoose.c:  if (*s == '-') {
mongoose.c:    neg = -1;
mongoose.c:    result += (*s - '0');
mongoose.c:      diff = str_util_lowercase(s1++) - str_util_lowercase(s2++);
mongoose.c:    } while (diff == 0 && s1[-1] != '\0' && --len > 0);
mongoose.c:    /* eCos and Windows are not standard-compliant and return -1 when
mongoose.c:        len = -1;
mongoose.c:      len = vsnprintf(*buf, size - 1, fmt, ap_copy);
mongoose.c:     * Microsoft version of vsnprintf() is not always null-terminated, so put
mongoose.c:    /* Standard-compliant code path. Allocate a buffer that is large enough. */
mongoose.c:      len = -1; /* LCOV_EXCL_LINE */
mongoose.c:      val->len = chr - val->p;
mongoose.c:      list.len -= (chr - list.p);
mongoose.c:      eq_val->len = 0;
mongoose.c:      eq_val->p = (const char *) memchr(val->p, '=', val->len);
mongoose.c:      if (eq_val->p != NULL) {
mongoose.c:        eq_val->p++; /* Skip over '=' character */
mongoose.c:        eq_val->len = val->p + val->len - eq_val->p;
mongoose.c:        val->len = (eq_val->p - val->p) - 1;
mongoose.c:    struct mg_str pstr = {pattern.p, (size_t)(or_str - pattern.p)};
mongoose.c:    pstr.len = (pattern.p + pattern.len) - (or_str + 1);
mongoose.c:      return j == str.len ? (int) j : -1;
mongoose.c:        len = str.len - j;
mongoose.c:        const struct mg_str pstr = {pattern.p + i, pattern.len - i};
mongoose.c:        const struct mg_str sstr = {str.p + j + len, str.len - j - len};
mongoose.c:      } while (res == -1 && len-- > 0);
mongoose.c:      return res == -1 ? -1 : (int) (j + res + len);
mongoose.c:      return -1;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.c:/* Which flags can be pre-set by the user at connection creation time. */
mongoose.c:  c->mgr = mgr;
mongoose.c:  c->next = mgr->active_connections;
mongoose.c:  mgr->active_connections = c;
mongoose.c:  c->prev = NULL;
mongoose.c:  if (c->next != NULL) c->next->prev = c;
mongoose.c:  if (c->sock != INVALID_SOCKET) {
mongoose.c:    c->iface->vtable->add_conn(c);
mongoose.c:  if (conn->prev == NULL) conn->mgr->active_connections = conn->next;
mongoose.c:  if (conn->prev) conn->prev->next = conn->next;
mongoose.c:  if (conn->next) conn->next->prev = conn->prev;
mongoose.c:  conn->prev = conn->next = NULL;
mongoose.c:  conn->iface->vtable->remove_conn(conn);
mongoose.c:     * If protocol handler is specified, call it. Otherwise, call user-specified
mongoose.c:    ev_handler = nc->proto_handler ? nc->proto_handler : nc->handler;
mongoose.c:         ev_handler == nc->handler ? "user" : "proto", ev, ev_data, nc->flags,
mongoose.c:         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));
mongoose.c:  if (nc->mgr->hexdump_file != NULL && ev != MG_EV_POLL && ev != MG_EV_RECV &&
mongoose.c:    mg_hexdump_connection(nc, nc->mgr->hexdump_file, NULL, 0, ev);
mongoose.c:    unsigned long flags_before = nc->flags;
mongoose.c:    size_t recv_mbuf_before = nc->recv_mbuf.len, recved;
mongoose.c:    recved = (recv_mbuf_before - nc->recv_mbuf.len);
mongoose.c:    if (ev_handler == nc->handler && nc->flags != flags_before) {
mongoose.c:      nc->flags = (flags_before & ~_MG_CALLBACK_MODIFIABLE_FLAGS_MASK) |
mongoose.c:                  (nc->flags & _MG_CALLBACK_MODIFIABLE_FLAGS_MASK);
mongoose.c:    /* It's important to not double-count recved bytes, and since mg_call can be
mongoose.c:    if (nesting_level == 1 && recved > 0 && !(nc->flags & MG_F_UDP)) {
mongoose.c:      nc->iface->vtable->recved(nc, recved);
mongoose.c:         ev_handler == nc->handler ? "user" : "proto", nc->flags,
mongoose.c:         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));
mongoose.c:  nesting_level--;
mongoose.c:  if (c->ev_timer_time > 0 && now >= c->ev_timer_time) {
mongoose.c:    double old_value = c->ev_timer_time;
mongoose.c:    c->ev_timer_time = 0;
mongoose.c:    mg_call(c, NULL, c->user_data, MG_EV_TIMER, &old_value);
mongoose.c:  if (!(nc->flags & MG_F_SSL) || (nc->flags & MG_F_SSL_HANDSHAKE_DONE)) {
mongoose.c:    mg_call(nc, NULL, nc->user_data, MG_EV_POLL, &now);
mongoose.c:  if (destroy_if) conn->iface->vtable->destroy_conn(conn);
mongoose.c:  if (conn->proto_data != NULL && conn->proto_data_destructor != NULL) {
mongoose.c:    conn->proto_data_destructor(conn->proto_data);
mongoose.c:  mbuf_free(&conn->recv_mbuf);
mongoose.c:  mbuf_free(&conn->send_mbuf);
mongoose.c:  DBG(("%p %lu %d", conn, conn->flags, conn->sock));
mongoose.c:  if (conn->flags & MG_F_SSL_HANDSHAKE_DONE) {
mongoose.c:  conn->iface->vtable->destroy_conn(conn);
mongoose.c:  mg_call(conn, NULL, conn->user_data, MG_EV_CLOSE, NULL);
mongoose.c:  m->ctl[0] = m->ctl[1] = INVALID_SOCKET;
mongoose.c:  m->user_data = user_data;
mongoose.c:    m->num_ifaces = opts.num_ifaces;
mongoose.c:    m->ifaces =
mongoose.c:        (struct mg_iface **) MG_MALLOC(sizeof(*m->ifaces) * opts.num_ifaces);
mongoose.c:      m->ifaces[i] = mg_if_create_iface(opts.ifaces[i], m);
mongoose.c:      m->ifaces[i]->vtable->init(m->ifaces[i]);
mongoose.c:    m->nameserver = strdup(opts.nameserver);
mongoose.c:  if (m->ctl[0] != INVALID_SOCKET) closesocket(m->ctl[0]);
mongoose.c:  if (m->ctl[1] != INVALID_SOCKET) closesocket(m->ctl[1]);
mongoose.c:  m->ctl[0] = m->ctl[1] = INVALID_SOCKET;
mongoose.c:  for (conn = m->active_connections; conn != NULL; conn = tmp_conn) {
mongoose.c:    tmp_conn = conn->next;
mongoose.c:    for (i = 0; i < m->num_ifaces; i++) {
mongoose.c:      m->ifaces[i]->vtable->free(m->ifaces[i]);
mongoose.c:      MG_FREE(m->ifaces[i]);
mongoose.c:    MG_FREE(m->ifaces);
mongoose.c:  MG_FREE((char *) m->nameserver);
mongoose.c:  if (m->num_ifaces == 0) {
mongoose.c:  for (i = 0; i < m->num_ifaces; i++) {
mongoose.c:    now = m->ifaces[i]->vtable->poll(m->ifaces[i], timeout_ms);
mongoose.c:/* TODO(lsm): use non-blocking resolver */
mongoose.c:  for (p = servinfo; p != NULL; p = p->ai_next) {
mongoose.c:    memcpy(&h, &p->ai_addr, sizeof(struct sockaddr_in *));
mongoose.c:    memcpy(ina, &h->sin_addr, sizeof(ina));
mongoose.c:    memcpy(ina, he->h_addr_list[0], sizeof(*ina));
mongoose.c:    conn->sock = INVALID_SOCKET;
mongoose.c:    conn->handler = callback;
mongoose.c:    conn->mgr = mgr;
mongoose.c:    conn->last_io_time = (time_t) mg_time();
mongoose.c:    conn->iface =
mongoose.c:        (opts.iface != NULL ? opts.iface : mgr->ifaces[MG_MAIN_IFACE]);
mongoose.c:    conn->flags = opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;
mongoose.c:    conn->user_data = opts.user_data;
mongoose.c:    conn->recv_mbuf_limit = ~0;
mongoose.c:  if (conn != NULL && !conn->iface->vtable->create_conn(conn)) {
mongoose.c: *   -1   on parse error
mongoose.c:   * Also, all-zeroes in the socket address means binding to all addresses
mongoose.c:  sa->sin.sin_family = AF_INET;
mongoose.c:    sa->sin.sin_addr.s_addr =
mongoose.c:    sa->sin.sin_port = htons((uint16_t) port);
mongoose.c:             inet_pton(AF_INET6, buf, &sa->sin6.sin6_addr)) {
mongoose.c:    sa->sin6.sin6_family = AF_INET6;
mongoose.c:    sa->sin.sin_port = htons((uint16_t) port);
mongoose.c:    sa->sin.sin_port = htons((uint16_t) port);
mongoose.c:       * we are trying to resolve is `localhost` - we should
mongoose.c:      if (!mg_resolve2(host, &sa->sin.sin_addr)) {
mongoose.c:        return -1;
mongoose.c:      return -1;
mongoose.c:    sa->sin.sin_port = htons((uint16_t) port);
mongoose.c:    return -1;
mongoose.c:  return port < 0xffffUL && (ch == '\0' || ch == ',' || isspace(ch)) ? len : -1;
mongoose.c:  nc = mg_create_connection(lc->mgr, lc->handler, opts);
mongoose.c:  nc->listener = lc;
mongoose.c:  nc->proto_handler = lc->proto_handler;
mongoose.c:  nc->user_data = lc->user_data;
mongoose.c:  nc->recv_mbuf_limit = lc->recv_mbuf_limit;
mongoose.c:  nc->iface = lc->iface;
mongoose.c:  if (lc->flags & MG_F_SSL) nc->flags |= MG_F_SSL;
mongoose.c:  mg_add_conn(nc->mgr, nc);
mongoose.c:  DBG(("%p %p %d %d", lc, nc, nc->sock, (int) nc->flags));
mongoose.c:  nc->sa = *sa;
mongoose.c:  mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);
mongoose.c:  nc->last_io_time = (time_t) mg_time();
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:    nc->iface->vtable->udp_send(nc, buf, len);
mongoose.c:    nc->iface->vtable->tcp_send(nc, buf, len);
mongoose.c:  if (nc->mgr && nc->mgr->hexdump_file != NULL) {
mongoose.c:    char *buf = nc->send_mbuf.buf;
mongoose.c:    mg_hexdump_connection(nc, nc->mgr->hexdump_file, buf, num_sent, MG_EV_SEND);
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    mbuf_remove(&nc->send_mbuf, num_sent);
mongoose.c:    mbuf_trim(&nc->send_mbuf);
mongoose.c:  mg_call(nc, NULL, nc->user_data, MG_EV_SEND, &num_sent);
mongoose.c:  DBG(("%p %d %u", nc, len, (unsigned int) nc->recv_mbuf.len));
mongoose.c:  if (nc->mgr && nc->mgr->hexdump_file != NULL) {
mongoose.c:    mg_hexdump_connection(nc, nc->mgr->hexdump_file, buf, len, MG_EV_RECV);
mongoose.c:  if (nc->flags & MG_F_CLOSE_IMMEDIATELY) {
mongoose.c:  nc->last_io_time = (time_t) mg_time();
mongoose.c:    mbuf_append(&nc->recv_mbuf, buf, len);
mongoose.c:  } else if (nc->recv_mbuf.len == 0) {
mongoose.c:    mbuf_free(&nc->recv_mbuf);
mongoose.c:    nc->recv_mbuf.buf = (char *) buf;
mongoose.c:    nc->recv_mbuf.size = nc->recv_mbuf.len = len;
mongoose.c:    mbuf_append(&nc->recv_mbuf, buf, len);
mongoose.c:  mg_call(nc, NULL, nc->user_data, MG_EV_RECV, &len);
mongoose.c:  assert(nc->flags & MG_F_UDP);
mongoose.c:  if (nc->flags & MG_F_LISTENING) {
mongoose.c:    for (nc = mg_next(lc->mgr, NULL); nc != NULL; nc = mg_next(lc->mgr, nc)) {
mongoose.c:      if (memcmp(&nc->sa.sa, &sa->sa, sa_len) == 0 && nc->listener == lc) {
mongoose.c:      nc = mg_create_connection_base(lc->mgr, lc->handler, opts);
mongoose.c:        nc->sock = lc->sock;
mongoose.c:        nc->listener = lc;
mongoose.c:        nc->sa = *sa;
mongoose.c:        nc->proto_handler = lc->proto_handler;
mongoose.c:        nc->user_data = lc->user_data;
mongoose.c:        nc->recv_mbuf_limit = lc->recv_mbuf_limit;
mongoose.c:        nc->flags = MG_F_UDP;
mongoose.c:         * Long-lived UDP "connections" i.e. interactions that involve more
mongoose.c:         * response is sent and the "connection" is closed. Or - should be.
mongoose.c:        nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:        mg_add_conn(lc->mgr, nc);
mongoose.c:        mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);
mongoose.c:    nc->iface->vtable->recved(nc, len);
mongoose.c:       inet_ntoa(sa->sin.sin_addr), ntohs(sa->sin.sin_port)));
mongoose.c:  nc->flags |= MG_F_CONNECTING;
mongoose.c:    nc->iface->vtable->connect_udp(nc);
mongoose.c:    nc->iface->vtable->connect_tcp(nc, sa);
mongoose.c:  mg_add_conn(nc->mgr, nc);
mongoose.c:  nc->flags &= ~MG_F_CONNECTING;
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  mg_call(nc, NULL, nc->user_data, MG_EV_CONNECT, &err);
mongoose.c:  int failure = -1;
mongoose.c:  nc->flags &= ~MG_F_RESOLVING;
mongoose.c:    for (i = 0; i < msg->num_answers; i++) {
mongoose.c:      if (msg->answers[i].rtype == MG_DNS_A_RECORD) {
mongoose.c:        mg_dns_parse_record_data(msg, &msg->answers[i], &nc->sa.sin.sin_addr,
mongoose.c:        mg_do_connect(nc, nc->flags & MG_F_UDP ? SOCK_DGRAM : SOCK_STREAM,
mongoose.c:                      &nc->sa);
mongoose.c:    mg_call(nc, NULL, nc->user_data, MG_EV_TIMER, &now);
mongoose.c:  mg_call(nc, NULL, nc->user_data, MG_EV_CONNECT, &failure);
mongoose.c:  mg_call(nc, NULL, nc->user_data, MG_EV_CLOSE, NULL);
mongoose.c:  if ((rc = mg_parse_address(address, &nc->sa, &proto, host, sizeof(host))) <
mongoose.c:  nc->flags |= opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;
mongoose.c:  nc->flags |= (proto == SOCK_DGRAM) ? MG_F_UDP : 0;
mongoose.c:  nc->user_data = user_data;
mongoose.c:  nc->user_data = opts.user_data;
mongoose.c:  DBG(("%p %s %s,%s,%s", nc, address, (opts.ssl_cert ? opts.ssl_cert : "-"),
mongoose.c:       (opts.ssl_key ? opts.ssl_key : "-"),
mongoose.c:       (opts.ssl_ca_cert ? opts.ssl_ca_cert : "-")));
mongoose.c:    if (nc->flags & MG_F_UDP) {
mongoose.c:    nc->flags |= MG_F_SSL;
mongoose.c:     * mg_parse_address() fills port in nc->sa, which we pass to resolve_cb()
mongoose.c:    if (mg_resolve_async_opt(nc->mgr, host, MG_DNS_A_RECORD, resolve_cb, nc,
mongoose.c:    nc->priv_2 = dns_conn;
mongoose.c:    nc->flags |= MG_F_RESOLVING;
mongoose.c:    return mg_do_connect(nc, proto, &nc->sa);
mongoose.c:  nc->sa = sa;
mongoose.c:  nc->flags |= MG_F_LISTENING;
mongoose.c:  if (proto == SOCK_DGRAM) nc->flags |= MG_F_UDP;
mongoose.c:  DBG(("%p %s %s,%s,%s", nc, address, (opts.ssl_cert ? opts.ssl_cert : "-"),
mongoose.c:       (opts.ssl_key ? opts.ssl_key : "-"),
mongoose.c:       (opts.ssl_ca_cert ? opts.ssl_ca_cert : "-")));
mongoose.c:    if (nc->flags & MG_F_UDP) {
mongoose.c:    nc->flags |= MG_F_SSL;
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:    rc = nc->iface->vtable->listen_udp(nc, &nc->sa);
mongoose.c:    rc = nc->iface->vtable->listen_tcp(nc, &nc->sa);
mongoose.c:  mg_add_conn(nc->mgr, nc);
mongoose.c:  return conn == NULL ? s->active_connections : conn->next;
mongoose.c:  if (mgr->ctl[0] != INVALID_SOCKET && data != NULL &&
mongoose.c:    dummy = MG_SEND_FUNC(mgr->ctl[0], (char *) &ctl_msg,
mongoose.c:    dummy = MG_RECV_FUNC(mgr->ctl[0], (char *) &len, 1, 0);
mongoose.c:    *mask = slash ? 0xffffffffU << (32 - slash) : 0;
mongoose.c:  allowed = (acl == NULL || *acl == '\0') ? '+' : '-';
mongoose.c:    if ((flag != '+' && flag != '-') ||
mongoose.c:      return -1;
mongoose.c:  mg_send(to, from->recv_mbuf.buf, from->recv_mbuf.len);
mongoose.c:  mbuf_remove(&from->recv_mbuf, from->recv_mbuf.len);
mongoose.c:  double result = c->ev_timer_time;
mongoose.c:  c->ev_timer_time = timestamp;
mongoose.c:  DBG(("%p %p %d -> %lu", c, c->priv_2, (c->flags & MG_F_RESOLVING ? 1 : 0),
mongoose.c:  if ((c->flags & MG_F_RESOLVING) && c->priv_2 != NULL) {
mongoose.c:    ((struct mg_connection *) c->priv_2)->ev_timer_time = timestamp;
mongoose.c:    nc->iface->vtable->sock_set(nc, sock);
mongoose.c:  nc->iface->vtable->get_conn_addr(nc, remote, sa);
mongoose.c:    mg_add_conn(nc->mgr, nc);
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:* Copyright (c) 2014-2017 Cesanta Software Limited
mongoose.c:  iface->mgr = mgr;
mongoose.c:  iface->data = NULL;
mongoose.c:  iface->vtable = vtable;
mongoose.c:    for (i = 0; i < mgr->num_ifaces; i++) {
mongoose.c:      if (mgr->ifaces[i] == from) {
mongoose.c:  for (; i < mgr->num_ifaces; i++) {
mongoose.c:    if (mgr->ifaces[i]->vtable == vtable) {
mongoose.c:      return mgr->ifaces[i];
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  nc->sock = socket(AF_INET, SOCK_STREAM, proto);
mongoose.c:  if (nc->sock == INVALID_SOCKET) {
mongoose.c:    nc->err = mg_get_errno() ? mg_get_errno() : 1;
mongoose.c:  mg_set_non_blocking_mode(nc->sock);
mongoose.c:  rc = connect(nc->sock, &sa->sa, sizeof(sa->sin));
mongoose.c:  nc->err = rc < 0 && mg_is_error() ? mg_get_errno() : 0;
mongoose.c:  DBG(("%p sock %d rc %d errno %d err %d", nc, nc->sock, rc, mg_get_errno(),
mongoose.c:       nc->err));
mongoose.c:  nc->sock = socket(AF_INET, SOCK_DGRAM, 0);
mongoose.c:  if (nc->sock == INVALID_SOCKET) {
mongoose.c:    nc->err = mg_get_errno() ? mg_get_errno() : 1;
mongoose.c:  if (nc->flags & MG_F_ENABLE_BROADCAST) {
mongoose.c:    setsockopt(nc->sock, SOL_SOCKET, SO_BROADCAST, (const char *) &optval,
mongoose.c:  nc->err = 0;
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  if (nc->sock == INVALID_SOCKET) return;
mongoose.c:  if (!(nc->flags & MG_F_UDP)) {
mongoose.c:    closesocket(nc->sock);
mongoose.c:    if (nc->listener == NULL) closesocket(nc->sock);
mongoose.c:  nc->sock = INVALID_SOCKET;
mongoose.c:  sock_t sock = accept(lc->sock, &sa.sa, &sa_len);
mongoose.c:  if (lc->flags & MG_F_SSL) {
mongoose.c:      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);
mongoose.c:  if ((sock = socket(sa->sa.sa_family, type, proto)) != INVALID_SOCKET &&
mongoose.c:       * SO_REUSEADDR was designed for, and leads to hard-to-track failure
mongoose.c:      !bind(sock, &sa->sa, sa_len) &&
mongoose.c:    (void) getsockname(sock, &sa->sa, &sa_len);
mongoose.c:  struct mbuf *io = &nc->send_mbuf;
mongoose.c:  if (io->len == 0) return;
mongoose.c:  assert(io->len > 0);
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:        sendto(nc->sock, io->buf, io->len, 0, &nc->sa.sa, sizeof(nc->sa.sin));
mongoose.c:    DBG(("%p %d %d %d %s:%hu", nc, nc->sock, n, mg_get_errno(),
mongoose.c:         inet_ntoa(nc->sa.sin.sin_addr), ntohs(nc->sa.sin.sin_port)));
mongoose.c:  if (nc->flags & MG_F_SSL) {
mongoose.c:    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {
mongoose.c:      n = mg_ssl_if_write(nc, io->buf, io->len);
mongoose.c:      DBG(("%p %d bytes -> %d (SSL)", nc, n, nc->sock));
mongoose.c:          nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        nc->flags &= ~(MG_F_WANT_READ | MG_F_WANT_WRITE);
mongoose.c:    n = (int) MG_SEND_FUNC(nc->sock, io->buf, io->len, 0);
mongoose.c:    DBG(("%p %d bytes -> %d", nc, n, nc->sock));
mongoose.c:  if (conn->recv_mbuf_limit < conn->recv_mbuf.len) return 0;
mongoose.c:  avail = conn->recv_mbuf_limit - conn->recv_mbuf.len;
mongoose.c:  if (conn->flags & MG_F_SSL) {
mongoose.c:    if (conn->flags & MG_F_SSL_HANDSHAKE_DONE) {
mongoose.c:        DBG(("%p %d bytes <- %d (SSL)", conn, n, conn->sock));
mongoose.c:        if (conn->flags & MG_F_CLOSE_IMMEDIATELY) break;
mongoose.c:      if (n < 0 && n != MG_SSL_WANT_READ) conn->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    n = (int) MG_RECV_FUNC(conn->sock, buf,
mongoose.c:    DBG(("%p %d bytes (PLAIN) <- %d", conn, n, conn->sock));
mongoose.c:      conn->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      conn->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    return -ENOMEM;
mongoose.c:  n = recvfrom(nc->sock, *buf, MG_UDP_RECV_BUFFER_SIZE, 0, &sa->sa, sa_len);
mongoose.c:  DBG(("%p %d bytes from %s:%d", nc, n, inet_ntoa(nc->sa.sin.sin_addr),
mongoose.c:       ntohs(nc->sa.sin.sin_port)));
mongoose.c:  int server_side = (nc->listener != NULL);
mongoose.c:    nc->flags |= MG_F_SSL_HANDSHAKE_DONE;
mongoose.c:    nc->flags &= ~(MG_F_WANT_READ | MG_F_WANT_WRITE);
mongoose.c:      (void) getpeername(nc->sock, &sa.sa, &sa_len);
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      fd_flags != 0 || (nc->flags & (MG_F_WANT_READ | MG_F_WANT_WRITE));
mongoose.c:    DBG(("%p fd=%d fd_flags=%d nc_flags=%lu rmbl=%d smbl=%d", nc, nc->sock,
mongoose.c:         fd_flags, nc->flags, (int) nc->recv_mbuf.len,
mongoose.c:         (int) nc->send_mbuf.len));
mongoose.c:  if (nc->flags & MG_F_CONNECTING) {
mongoose.c:      if (!(nc->flags & MG_F_UDP)) {
mongoose.c:            getsockopt(nc->sock, SOL_SOCKET, SO_ERROR, (char *) &err, &len);
mongoose.c:      err = nc->err;
mongoose.c:      if ((nc->flags & MG_F_SSL) && err == 0) {
mongoose.c:    } else if (nc->err != 0) {
mongoose.c:      mg_if_connect_cb(nc, nc->err);
mongoose.c:    if (nc->flags & MG_F_UDP) {
mongoose.c:      if (nc->flags & MG_F_LISTENING) {
mongoose.c:         * a time. The reason is that eCos does not respect non-blocking
mongoose.c:  if (!(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {
mongoose.c:    if ((fd_flags & _MG_F_FD_CAN_WRITE) && nc->send_mbuf.len > 0) {
mongoose.c:    DBG(("%p after fd=%d nc_flags=%lu rmbl=%d smbl=%d", nc, nc->sock, nc->flags,
mongoose.c:         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));
mongoose.c:      (int) MG_RECV_FUNC(mgr->ctl[1], (char *) &ctl_msg, sizeof(ctl_msg), 0);
mongoose.c:  size_t dummy = MG_SEND_FUNC(mgr->ctl[1], ctl_msg.message, 1, 0);
mongoose.c:                       ctl_msg.message MG_UD_ARG(nc->user_data));
mongoose.c:  nc->sock = sock;
mongoose.c:  DBG(("%p using select()", iface->mgr));
mongoose.c:  mg_socketpair(iface->mgr->ctl, SOCK_DGRAM);
mongoose.c:  struct mg_mgr *mgr = iface->mgr;
mongoose.c:  mg_add_to_set(mgr->ctl[1], &read_set, &max_fd);
mongoose.c:   * e.g. timer-only "connections".
mongoose.c:  for (nc = mgr->active_connections, num_fds = 0; nc != NULL; nc = tmp) {
mongoose.c:    tmp = nc->next;
mongoose.c:    if (nc->sock != INVALID_SOCKET) {
mongoose.c:      if (nc->sock >= (sock_t) FD_SETSIZE && try_dup) {
mongoose.c:        int new_sock = dup(nc->sock);
mongoose.c:          closesocket(nc->sock);
mongoose.c:          DBG(("new sock %d -> %d", nc->sock, new_sock));
mongoose.c:          nc->sock = new_sock;
mongoose.c:      if (!(nc->flags & MG_F_WANT_WRITE) &&
mongoose.c:          nc->recv_mbuf.len < nc->recv_mbuf_limit &&
mongoose.c:          (!(nc->flags & MG_F_UDP) || nc->listener == NULL)) {
mongoose.c:        mg_add_to_set(nc->sock, &read_set, &max_fd);
mongoose.c:      if (((nc->flags & MG_F_CONNECTING) && !(nc->flags & MG_F_WANT_READ)) ||
mongoose.c:          (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING))) {
mongoose.c:        mg_add_to_set(nc->sock, &write_set, &max_fd);
mongoose.c:        mg_add_to_set(nc->sock, &err_set, &max_fd);
mongoose.c:    if (nc->ev_timer_time > 0) {
mongoose.c:      if (num_timers == 0 || nc->ev_timer_time < min_timer) {
mongoose.c:        min_timer = nc->ev_timer_time;
mongoose.c:    double timer_timeout_ms = (min_timer - mg_time()) * 1000 + 1 /* rounding */;
mongoose.c:  if (num_ev > 0 && mgr->ctl[1] != INVALID_SOCKET &&
mongoose.c:      FD_ISSET(mgr->ctl[1], &read_set)) {
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    if (nc->sock != INVALID_SOCKET) {
mongoose.c:        fd_flags = (FD_ISSET(nc->sock, &read_set) &&
mongoose.c:                            (!(nc->flags & MG_F_UDP) || nc->listener == NULL)
mongoose.c:                   (FD_ISSET(nc->sock, &write_set) ? _MG_F_FD_CAN_WRITE : 0) |
mongoose.c:                   (FD_ISSET(nc->sock, &err_set) ? _MG_F_FD_ERROR : 0);
mongoose.c:      if ((nc->flags & MG_F_UDP) && nc->listener == NULL) {
mongoose.c:    tmp = nc->next;
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    tmp = nc->next;
mongoose.c:    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||
mongoose.c:        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {
mongoose.c:    if (closesocket(*sock) == -1 && errno == EINTR) continue;
mongoose.c:    if ((rc = accept(sock, &sa->sa, &sa_len)) == INVALID_SOCKET &&
mongoose.c:    getpeername(sock, &sa->sa, &slen);
mongoose.c:    getsockname(sock, &sa->sa, &slen);
mongoose.c:  if ((nc->flags & MG_F_UDP) && remote) {
mongoose.c:    memcpy(sa, &nc->sa, sizeof(*sa));
mongoose.c:  mg_sock_get_addr(nc->sock, remote, sa);
mongoose.c:/* clang-format off */
mongoose.c:/* clang-format on */
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  LOG(LL_DEBUG, ("disbanding proxy %p %p", d->c, d->s));
mongoose.c:  if (d->c) d->c->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  if (d->s) d->s->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  d->c = d->s = NULL;
mongoose.c:  struct socksdata *d = (struct socksdata *) c->user_data;
mongoose.c:      mg_send(d->s, buf, sizeof(buf));
mongoose.c:      LOG(LL_DEBUG, ("Sent handshake to %s", d->proxy_addr));
mongoose.c:      LOG(LL_ERROR, ("Cannot connect to %s: %d", d->proxy_addr, res));
mongoose.c:      d->c->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    if (!(c->flags & MG_SOCKS_HANDSHAKE_DONE)) {
mongoose.c:      if (c->recv_mbuf.len < 2) return;
mongoose.c:      if ((unsigned char) c->recv_mbuf.buf[1] == MG_SOCKS_HANDSHAKE_FAILURE) {
mongoose.c:      mbuf_remove(&c->recv_mbuf, 2);
mongoose.c:      c->flags |= MG_SOCKS_HANDSHAKE_DONE;
mongoose.c:      memcpy(buf + 4, &d->c->sa.sin.sin_addr, 4);
mongoose.c:      memcpy(buf + 8, &d->c->sa.sin.sin_port, 2);
mongoose.c:    if ((c->flags & MG_SOCKS_HANDSHAKE_DONE) &&
mongoose.c:        !(c->flags & MG_SOCKS_CONNECT_DONE)) {
mongoose.c:      if (c->recv_mbuf.len < 10) return;
mongoose.c:      if (c->recv_mbuf.buf[1] != MG_SOCKS_SUCCESS) {
mongoose.c:        LOG(LL_ERROR, ("Socks connection error: %d", c->recv_mbuf.buf[1]));
mongoose.c:      mbuf_remove(&c->recv_mbuf, 10);
mongoose.c:      c->flags |= MG_SOCKS_CONNECT_DONE;
mongoose.c:      if (d->s && d->c) {
mongoose.c:        mbuf_append(&d->s->send_mbuf, d->tmp.buf, d->tmp.len);
mongoose.c:        mbuf_free(&d->tmp);
mongoose.c:    if ((c->flags & MG_SOCKS_CONNECT_DONE) && d->c && d->s) {
mongoose.c:      mbuf_append(&d->c->recv_mbuf, d->s->recv_mbuf.buf, d->s->recv_mbuf.len);
mongoose.c:      mbuf_remove(&d->s->recv_mbuf, d->s->recv_mbuf.len);
mongoose.c:  struct socksdata *d = (struct socksdata *) c->iface->data;
mongoose.c:  d->c = c;
mongoose.c:  d->s = mg_connect(c->mgr, d->proxy_addr, socks_if_handler);
mongoose.c:  d->s->user_data = d;
mongoose.c:  LOG(LL_DEBUG, ("%p %s", c, d->proxy_addr));
mongoose.c:  return -1;
mongoose.c:  struct socksdata *d = (struct socksdata *) c->iface->data;
mongoose.c:  LOG(LL_DEBUG, ("%p -> %p %d %d", c, buf, (int) len, (int) c->send_mbuf.len));
mongoose.c:  if (d && d->s && d->s->flags & MG_SOCKS_CONNECT_DONE) {
mongoose.c:    mbuf_append(&d->s->send_mbuf, d->tmp.buf, d->tmp.len);
mongoose.c:    mbuf_append(&d->s->send_mbuf, buf, len);
mongoose.c:    mbuf_free(&d->tmp);
mongoose.c:    mbuf_append(&d->tmp, buf, len);
mongoose.c:  c->iface->vtable->free(c->iface);
mongoose.c:  MG_FREE(c->iface);
mongoose.c:  c->iface = NULL;
mongoose.c:  struct socksdata *d = (struct socksdata *) iface->data;
mongoose.c:    mbuf_free(&d->tmp);
mongoose.c:    MG_FREE(d->proxy_addr);
mongoose.c:    iface->data = NULL;
mongoose.c:  c->sock = INVALID_SOCKET;
mongoose.c:  iface->data = MG_CALLOC(1, sizeof(struct socksdata));
mongoose.c:  ((struct socksdata *) iface->data)->proxy_addr = strdup(proxy_addr);
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  return -1;
mongoose.c:  struct mg_tun_client *client = (struct mg_tun_client *) nc->iface->data;
mongoose.c:  uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;
mongoose.c:  mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME, 0, msg);
mongoose.c:  struct mg_tun_client *client = (struct mg_tun_client *) nc->iface->data;
mongoose.c:  if (nc->flags & MG_F_LISTENING) {
mongoose.c:  } else if (client->disp) {
mongoose.c:    uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;
mongoose.c:    mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME,
mongoose.c:  nc->sock = INVALID_SOCKET;
mongoose.c:  for (nc = client->mgr->active_connections; nc != NULL; nc = nc->next) {
mongoose.c:    if (nc->iface != client->iface || (nc->flags & MG_F_LISTENING)) {
mongoose.c:    if (stream_id == (uint32_t)(uintptr_t) nc->mgr_data) {
mongoose.c:  if (stream_id > client->last_stream_id) {
mongoose.c:    nc = mg_if_accept_new_conn(client->listener);
mongoose.c:    nc->mgr_data = (void *) (uintptr_t) stream_id;
mongoose.c:    client->last_stream_id = stream_id;
mongoose.c:         (unsigned int) client->last_stream_id));
mongoose.c:/* clang-format off */
mongoose.c:/* clang-format on */
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
mongoose.c:  struct mg_ssl_if_ctx *lc_ctx = (struct mg_ssl_if_ctx *) lc->ssl_if_data;
mongoose.c:  nc->ssl_if_data = ctx;
mongoose.c:  ctx->ssl_ctx = lc_ctx->ssl_ctx;
mongoose.c:  if ((ctx->ssl = SSL_new(ctx->ssl_ctx)) == NULL) {
mongoose.c:  DBG(("%p %s,%s,%s", nc, (params->cert ? params->cert : ""),
mongoose.c:       (params->key ? params->key : ""),
mongoose.c:       (params->ca_cert ? params->ca_cert : "")));
mongoose.c:  nc->ssl_if_data = ctx;
mongoose.c:  if (nc->flags & MG_F_LISTENING) {
mongoose.c:    ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method());
mongoose.c:    ctx->ssl_ctx = SSL_CTX_new(SSLv23_client_method());
mongoose.c:  if (ctx->ssl_ctx == NULL) {
mongoose.c:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_SSLv2);
mongoose.c:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_SSLv3);
mongoose.c:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1);
mongoose.c:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);
mongoose.c:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
mongoose.c:  if (params->cert != NULL &&
mongoose.c:      mg_use_cert(ctx->ssl_ctx, params->cert, params->key, err_msg) !=
mongoose.c:  if (params->ca_cert != NULL &&
mongoose.c:      mg_use_ca_cert(ctx->ssl_ctx, params->ca_cert) != MG_SSL_OK) {
mongoose.c:  if (params->server_name != NULL) {
mongoose.c:    SSL_CTX_kr_set_verify_name(ctx->ssl_ctx, params->server_name);
mongoose.c:  if (mg_set_cipher_list(ctx->ssl_ctx, params->cipher_suites) != MG_SSL_OK) {
mongoose.c:  mbuf_init(&ctx->psk, 0);
mongoose.c:  if (mg_ssl_if_ossl_set_psk(ctx, params->psk_identity, params->psk_key) !=
mongoose.c:  if (!(nc->flags & MG_F_LISTENING) &&
mongoose.c:      (ctx->ssl = SSL_new(ctx->ssl_ctx)) == NULL) {
mongoose.c:  nc->flags |= MG_F_SSL;
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  int err = SSL_get_error(ctx->ssl, res);
mongoose.c:  DBG(("%p %p SSL error: %d %d", nc, ctx->ssl_ctx, res, err));
mongoose.c:  nc->err = err;
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  int server_side = (nc->listener != NULL);
mongoose.c:  if (SSL_get_fd(ctx->ssl) < 0) {
mongoose.c:    if (SSL_set_fd(ctx->ssl, nc->sock) != 1) return MG_SSL_ERROR;
mongoose.c:  res = server_side ? SSL_accept(ctx->ssl) : SSL_connect(ctx->ssl);
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  int n = SSL_read(ctx->ssl, buf, buf_size);
mongoose.c:  DBG(("%p %d -> %d", nc, (int) buf_size, n));
mongoose.c:  if (n == 0) nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  int n = SSL_write(ctx->ssl, data, len);
mongoose.c:  DBG(("%p %d -> %d", nc, (int) len, n));
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  SSL_shutdown(ctx->ssl);
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  nc->ssl_if_data = NULL;
mongoose.c:  if (ctx->ssl != NULL) SSL_free(ctx->ssl);
mongoose.c:  if (ctx->ssl_ctx != NULL && nc->listener == NULL) SSL_CTX_free(ctx->ssl_ctx);
mongoose.c:  mbuf_free(&ctx->psk);
mongoose.c:    "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:"
mongoose.c:    "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:"
mongoose.c:    "DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:"
mongoose.c:    "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:"
mongoose.c:    "ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:"
mongoose.c:    "ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:"
mongoose.c:    "DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:"
mongoose.c:    "DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:"
mongoose.c:    "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:"
mongoose.c:    "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:"
mongoose.c:    "DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:"
mongoose.c:    "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:"
mongoose.c:    "ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:"
mongoose.c:    "ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:"
mongoose.c:    "DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:"
mongoose.c:    "DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:"
mongoose.c:    "ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:"
mongoose.c:    "AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:"
mongoose.c:    "!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA"
mongoose.c:#else /* Default - intermediate. */
mongoose.c:    "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:"
mongoose.c:    "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:"
mongoose.c:    "DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:"
mongoose.c:    "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:"
mongoose.c:    "ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:"
mongoose.c:    "ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:"
mongoose.c:    "DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:"
mongoose.c:    "DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:"
mongoose.c:    "AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:"
mongoose.c:    "DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:"
mongoose.c:    "!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA"
mongoose.c: * Default DH params for PFS cipher negotiation. This is a 2048-bit group.
mongoose.c:-----BEGIN DH PARAMETERS-----\n\
mongoose.c:-----END DH PARAMETERS-----\n";
mongoose.c:     * If there are no DH params in the file, fall back to hard-coded ones.
mongoose.c:      bio = BIO_new_mem_buf((void *) mg_s_default_dh_params, -1);
mongoose.c:  size_t key_len = ctx->psk.len - ctx->identity_len - 1;
mongoose.c:  if (ctx->identity_len + 1 > max_identity_len) {
mongoose.c:  memcpy(identity, ctx->psk.buf, ctx->identity_len + 1);
mongoose.c:  memcpy(psk, ctx->psk.buf + ctx->identity_len + 1, key_len);
mongoose.c:      c = hc - '0';
mongoose.c:      c = hc - 'a' + 0xa;
mongoose.c:  ctx->identity_len = strlen(identity);
mongoose.c:  mbuf_append(&ctx->psk, identity, ctx->identity_len + 1);
mongoose.c:  mbuf_append(&ctx->psk, key, key_len);
mongoose.c:  SSL_CTX_set_psk_client_callback(ctx->ssl_ctx, mg_ssl_if_ossl_psk_cb);
mongoose.c:  SSL_CTX_set_app_data(ctx->ssl_ctx, ctx);
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  LOG(cs_level, ("%p %.*s", ctx, (int) (strlen(str) - 1), str));
mongoose.c:  struct mg_ssl_if_ctx *lc_ctx = (struct mg_ssl_if_ctx *) lc->ssl_if_data;
mongoose.c:  nc->ssl_if_data = ctx;
mongoose.c:  ctx->ssl = (mbedtls_ssl_context *) MG_CALLOC(1, sizeof(*ctx->ssl));
mongoose.c:  if (mbedtls_ssl_setup(ctx->ssl, lc_ctx->conf) != 0) {
mongoose.c:  DBG(("%p %s,%s,%s", nc, (params->cert ? params->cert : ""),
mongoose.c:       (params->key ? params->key : ""),
mongoose.c:       (params->ca_cert ? params->ca_cert : "")));
mongoose.c:  nc->ssl_if_data = ctx;
mongoose.c:  ctx->conf = (mbedtls_ssl_config *) MG_CALLOC(1, sizeof(*ctx->conf));
mongoose.c:  mbuf_init(&ctx->cipher_suites, 0);
mongoose.c:  mbedtls_ssl_config_init(ctx->conf);
mongoose.c:  mbedtls_ssl_conf_dbg(ctx->conf, mg_ssl_mbed_log, nc);
mongoose.c:          ctx->conf, (nc->flags & MG_F_LISTENING ? MBEDTLS_SSL_IS_SERVER
mongoose.c:  mbedtls_ssl_conf_min_version(ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3,
mongoose.c:  mbedtls_ssl_conf_rng(ctx->conf, mg_ssl_if_mbed_random, nc);
mongoose.c:  if (params->cert != NULL &&
mongoose.c:      mg_use_cert(ctx, params->cert, params->key, err_msg) != MG_SSL_OK) {
mongoose.c:  if (params->ca_cert != NULL &&
mongoose.c:      mg_use_ca_cert(ctx, params->ca_cert) != MG_SSL_OK) {
mongoose.c:  if (mg_set_cipher_list(ctx, params->cipher_suites) != MG_SSL_OK) {
mongoose.c:  if (mg_ssl_if_mbed_set_psk(ctx, params->psk_identity, params->psk_key) !=
mongoose.c:  if (!(nc->flags & MG_F_LISTENING)) {
mongoose.c:    ctx->ssl = (mbedtls_ssl_context *) MG_CALLOC(1, sizeof(*ctx->ssl));
mongoose.c:    mbedtls_ssl_init(ctx->ssl);
mongoose.c:    if (mbedtls_ssl_setup(ctx->ssl, ctx->conf) != 0) {
mongoose.c:    if (params->server_name != NULL &&
mongoose.c:        mbedtls_ssl_set_hostname(ctx->ssl, params->server_name) != 0) {
mongoose.c:  if (mbedtls_ssl_conf_max_frag_len(ctx->conf,
mongoose.c:  nc->flags |= MG_F_SSL;
mongoose.c:  int n = (int) MG_SEND_FUNC(nc->sock, buf, len, 0);
mongoose.c:  LOG(LL_DEBUG, ("%p %d -> %d", nc, (int) len, n));
mongoose.c:  return ((n == EAGAIN || n == EINPROGRESS) ? MBEDTLS_ERR_SSL_WANT_WRITE : -1);
mongoose.c:  int n = (int) MG_RECV_FUNC(nc->sock, buf, len, 0);
mongoose.c:  LOG(LL_DEBUG, ("%p %d <- %d", nc, (int) len, n));
mongoose.c:  return ((n == EAGAIN || n == EINPROGRESS) ? MBEDTLS_ERR_SSL_WANT_READ : -1);
mongoose.c:  nc->err = ret;
mongoose.c:  nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  if (ctx->cert != NULL) {
mongoose.c:    mbedtls_x509_crt_free(ctx->cert);
mongoose.c:    MG_FREE(ctx->cert);
mongoose.c:    ctx->cert = NULL;
mongoose.c:    mbedtls_pk_free(ctx->key);
mongoose.c:    MG_FREE(ctx->key);
mongoose.c:    ctx->key = NULL;
mongoose.c:  if (ctx->ca_cert != NULL) {
mongoose.c:    mbedtls_ssl_conf_ca_chain(ctx->conf, NULL, NULL);
mongoose.c:    if (ctx->ca_cert->ca_chain_file != NULL) {
mongoose.c:      MG_FREE((void *) ctx->ca_cert->ca_chain_file);
mongoose.c:      ctx->ca_cert->ca_chain_file = NULL;
mongoose.c:    mbedtls_x509_crt_free(ctx->ca_cert);
mongoose.c:    MG_FREE(ctx->ca_cert);
mongoose.c:    ctx->ca_cert = NULL;
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  if (ctx->ssl->p_bio == NULL) {
mongoose.c:    mbedtls_ssl_set_bio(ctx->ssl, nc, ssl_socket_send, ssl_socket_recv, NULL);
mongoose.c:  err = mbedtls_ssl_handshake(ctx->ssl);
mongoose.c:  mbedtls_x509_crt_free(ctx->ssl->session->peer_cert);
mongoose.c:  mbedtls_free(ctx->ssl->session->peer_cert);
mongoose.c:  ctx->ssl->session->peer_cert = NULL;
mongoose.c:  if (nc->listener == NULL) {
mongoose.c:    if (ctx->conf->key_cert != NULL) {
mongoose.c:      MG_FREE(ctx->conf->key_cert);
mongoose.c:      ctx->conf->key_cert = NULL;
mongoose.c:    mbedtls_ssl_conf_ca_chain(ctx->conf, NULL, NULL);
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  int n = mbedtls_ssl_read(ctx->ssl, (unsigned char *) buf, buf_size);
mongoose.c:  DBG(("%p %d -> %d", nc, (int) buf_size, n));
mongoose.c:  if (n == 0) nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  int n = mbedtls_ssl_write(ctx->ssl, (const unsigned char *) data, len);
mongoose.c:  DBG(("%p %d -> %d", nc, (int) len, n));
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  mbedtls_ssl_close_notify(ctx->ssl);
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  nc->ssl_if_data = NULL;
mongoose.c:  if (ctx->ssl != NULL) {
mongoose.c:    mbedtls_ssl_free(ctx->ssl);
mongoose.c:    MG_FREE(ctx->ssl);
mongoose.c:  if (ctx->conf != NULL) {
mongoose.c:    mbedtls_ssl_config_free(ctx->conf);
mongoose.c:    MG_FREE(ctx->conf);
mongoose.c:  mbuf_free(&ctx->cipher_suites);
mongoose.c:    mbedtls_ssl_conf_authmode(ctx->conf, MBEDTLS_SSL_VERIFY_NONE);
mongoose.c:  ctx->ca_cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->ca_cert));
mongoose.c:  mbedtls_x509_crt_init(ctx->ca_cert);
mongoose.c:  if (mbedtls_x509_crt_set_ca_chain_file(ctx->ca_cert, ca_cert) != 0) {
mongoose.c:  if (mbedtls_x509_crt_parse_file(ctx->ca_cert, ca_cert) != 0) {
mongoose.c:  mbedtls_ssl_conf_ca_chain(ctx->conf, ctx->ca_cert, NULL);
mongoose.c:  mbedtls_ssl_conf_authmode(ctx->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
mongoose.c:  ctx->cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->cert));
mongoose.c:  mbedtls_x509_crt_init(ctx->cert);
mongoose.c:  ctx->key = (mbedtls_pk_context *) MG_CALLOC(1, sizeof(*ctx->key));
mongoose.c:  mbedtls_pk_init(ctx->key);
mongoose.c:  if (mbedtls_x509_crt_parse_file(ctx->cert, cert) != 0) {
mongoose.c:  if (mbedtls_pk_parse_keyfile(ctx->key, key, NULL) != 0) {
mongoose.c:  if (mbedtls_ssl_conf_own_cert(ctx->conf, ctx->cert, ctx->key) != 0) {
mongoose.c: * Ciphers can be specified as a colon-separated list of cipher suite names.
mongoose.c: * E.g.: TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-CCM
mongoose.c:      l = (e != NULL ? (e - s) : (int) strlen(s));
mongoose.c:      DBG(("%s -> %04x", tmp, id));
mongoose.c:        mbuf_append(&ctx->cipher_suites, &id, sizeof(id));
mongoose.c:    if (ctx->cipher_suites.len == 0) return MG_SSL_ERROR;
mongoose.c:    mbuf_append(&ctx->cipher_suites, &id, sizeof(id));
mongoose.c:    mbuf_trim(&ctx->cipher_suites);
mongoose.c:    mbedtls_ssl_conf_ciphersuites(ctx->conf,
mongoose.c:                                  (const int *) ctx->cipher_suites.buf);
mongoose.c:    mbedtls_ssl_conf_ciphersuites(ctx->conf, mg_s_cipher_list);
mongoose.c:      c = hc - '0';
mongoose.c:      c = hc - 'a' + 0xa;
mongoose.c:  if (mbedtls_ssl_conf_psk(ctx->conf, (const unsigned char *) key, key_len,
mongoose.c:  while (len--) *buf++ = rand();
mongoose.c:  res->p = *p;
mongoose.c:  res->len = (*p) - res->p;
mongoose.c:         * - `scheme://xxxx`
mongoose.c:         * - `xxxx:port`
mongoose.c:         * - `[a:b:c]:port`
mongoose.c:         * - `xxxx/path`
mongoose.c:          rhost.len = p - uri.p;
mongoose.c:        if (end - p >= 3 && strncmp(p, "://", 3) == 0) {
mongoose.c:          rscheme.len = p - uri.p;
mongoose.c:          rhost.len = p - uri.p;
mongoose.c:        ruser_info.len = p - ruser_info.p;
mongoose.c:          if (!found) return -1;
mongoose.c:        rhost.len = p - rhost.p;
mongoose.c:          rport += *p - '0';
mongoose.c:        if (p < end && *(p - 1) == '?') {
mongoose.c:  const char *s = in->p, *se = s + in->len;
mongoose.c:  char *cp = (char *) out->p, *d;
mongoose.c:  if (in->len == 0 || *s != '/') {
mongoose.c:    out->len = 0;
mongoose.c:      if (d > cp + 1 && *(d - 1) == '/') d--;
mongoose.c:      while (d > cp && *(d - 1) != '/') d--;
mongoose.c:      memmove(d, s, next - s);
mongoose.c:      d += next - s;
mongoose.c:  out->p = cp;
mongoose.c:  out->len = d - cp;
mongoose.c:  int result = -1;
mongoose.c:  if (scheme != NULL && scheme->len > 0) {
mongoose.c:    mbuf_append(&out, scheme->p, scheme->len);
mongoose.c:  if (user_info != NULL && user_info->len > 0) {
mongoose.c:    mbuf_append(&out, user_info->p, user_info->len);
mongoose.c:  if (host != NULL && host->len > 0) {
mongoose.c:    mbuf_append(&out, host->p, host->len);
mongoose.c:  if (path != NULL && path->len > 0) {
mongoose.c:      if (npath.len != path->len) goto out;
mongoose.c:      mbuf_append(&out, path->p, path->len);
mongoose.c:  if (query != NULL && query->len > 0) {
mongoose.c:    mbuf_append(&out, query->p, query->len);
mongoose.c:  if (fragment != NULL && fragment->len > 0) {
mongoose.c:    mbuf_append(&out, fragment->p, fragment->len);
mongoose.c:    uri->p = out.buf;
mongoose.c:    uri->len = out.len;
mongoose.c:    uri->p = NULL;
mongoose.c:    uri->len = 0;
mongoose.c:  int64_t cl;    /* Content-Length. How many bytes to send. */
mongoose.c:  if (c->proto_data == NULL) {
mongoose.c:    c->proto_data = MG_CALLOC(1, sizeof(struct mg_http_proto_data));
mongoose.c:    c->proto_data_destructor = mg_http_conn_destructor;
mongoose.c:  return (struct mg_http_proto_data *) c->proto_data;
mongoose.c:  MG_FREE((void *) mp->boundary);
mongoose.c:  MG_FREE((void *) mp->var_name);
mongoose.c:  MG_FREE((void *) mp->file_name);
mongoose.c:    if (d->fp != NULL) {
mongoose.c:      fclose(d->fp);
mongoose.c:    struct mg_http_endpoint *tmp = current->next;
mongoose.c:    MG_FREE((void *) current->uri_pattern.p);
mongoose.c:    MG_FREE((void *) current->auth_domain);
mongoose.c:    MG_FREE((void *) current->auth_file);
mongoose.c:  if (rpd->linked_conn != NULL) {
mongoose.c:    struct mg_http_proto_data *pd = mg_http_get_proto_data(rpd->linked_conn);
mongoose.c:    if (pd->reverse_proxy_data.linked_conn != NULL) {
mongoose.c:      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      pd->reverse_proxy_data.linked_conn = NULL;
mongoose.c:    rpd->linked_conn = NULL;
mongoose.c:  mg_http_free_proto_data_file(&pd->file);
mongoose.c:  mg_http_free_proto_data_cgi(&pd->cgi);
mongoose.c:  mg_http_free_proto_data_mp_stream(&pd->mp_stream);
mongoose.c:  mg_http_free_proto_data_endpoints(&pd->endpoints);
mongoose.c:  mg_http_free_reverse_proxy_data(&pd->reverse_proxy_data);
mongoose.c:  { _ext, sizeof(_ext) - 1, _type }
mongoose.c:    MIME_ENTRY("js", "application/x-javascript"),
mongoose.c:    MIME_ENTRY("ico", "image/x-icon"),
mongoose.c:    MIME_ENTRY("torrent", "application/x-bittorrent"),
mongoose.c:    MIME_ENTRY("wav", "audio/x-wav"),
mongoose.c:    MIME_ENTRY("mp3", "audio/x-mp3"),
mongoose.c:    MIME_ENTRY("m3u", "audio/x-mpegurl"),
mongoose.c:    MIME_ENTRY("ram", "audio/x-pn-realaudio"),
mongoose.c:    MIME_ENTRY("ttf", "application/x-font-ttf"),
mongoose.c:    MIME_ENTRY("ra", "audio/x-pn-realaudio"),
mongoose.c:    MIME_ENTRY("exe", "application/octet-stream"),
mongoose.c:    MIME_ENTRY("zip", "application/x-zip-compressed"),
mongoose.c:    MIME_ENTRY("tgz", "application/x-tar-gz"),
mongoose.c:    MIME_ENTRY("tar", "application/x-tar"),
mongoose.c:    MIME_ENTRY("gz", "application/x-gunzip"),
mongoose.c:    MIME_ENTRY("arj", "application/x-arj-compressed"),
mongoose.c:    MIME_ENTRY("rar", "application/x-rar-compressed"),
mongoose.c:    MIME_ENTRY("swf", "application/x-shockwave-flash"),
mongoose.c:    MIME_ENTRY("m4v", "video/x-m4v"),
mongoose.c:    MIME_ENTRY("asf", "video/x-ms-asf"),
mongoose.c:    MIME_ENTRY("avi", "video/x-msvideo"),
mongoose.c:  overrides = opts->custom_mime_types;
mongoose.c:    ext = path + (path_len - k.len);
mongoose.c:    ext = path + (path_len - mg_static_builtin_mime_types[i].ext_len);
mongoose.c:    if (path_len > mg_static_builtin_mime_types[i].ext_len && ext[-1] == '.' &&
mongoose.c: *   -1  if request is malformed
mongoose.c:      return -1;
mongoose.c:  while (i < (int) ARRAY_SIZE(req->header_names) - 1) {
mongoose.c:    struct mg_str *k = &req->header_names[i], *v = &req->header_values[i];
mongoose.c:    while (v->len > 0 && v->p[v->len - 1] == ' ') {
mongoose.c:      v->len--; /* Trim trailing spaces in header value */
mongoose.c:     * If header value is empty - skip it and go to next (if any).
mongoose.c:    if (k->len != 0 && v->len == 0) {
mongoose.c:    if (k->len == 0 || v->len == 0) {
mongoose.c:      k->p = v->p = NULL;
mongoose.c:      k->len = v->len = 0;
mongoose.c:    if (!mg_ncasecmp(k->p, "Content-Length", 14)) {
mongoose.c:      req->body.len = (size_t) to64(v->p);
mongoose.c:      req->message.len = len + req->body.len;
mongoose.c:  hm->message.p = s;
mongoose.c:  hm->body.p = s + len;
mongoose.c:  hm->message.len = hm->body.len = (size_t) ~0;
mongoose.c:    s = mg_skip(s, end, " ", &hm->method);
mongoose.c:    s = mg_skip(s, end, " ", &hm->uri);
mongoose.c:    s = mg_skip(s, end, "\r\n", &hm->proto);
mongoose.c:    if (hm->uri.p <= hm->method.p || hm->proto.p <= hm->uri.p) return -1;
mongoose.c:    if ((qs = (char *) memchr(hm->uri.p, '?', hm->uri.len)) != NULL) {
mongoose.c:      hm->query_string.p = qs + 1;
mongoose.c:      hm->query_string.len = &hm->uri.p[hm->uri.len] - (qs + 1);
mongoose.c:      hm->uri.len = qs - hm->uri.p;
mongoose.c:    s = mg_skip(s, end, " ", &hm->proto);
mongoose.c:    if (end - s < 4 || s[3] != ' ') return -1;
mongoose.c:    hm->resp_code = atoi(s);
mongoose.c:    if (hm->resp_code < 100 || hm->resp_code >= 600) return -1;
mongoose.c:    s = mg_skip(s, end, "\r\n", &hm->resp_status_msg);
mongoose.c:   * responses. If HTTP response does not have Content-Length set, then
mongoose.c:   * http://tools.ietf.org/html/rfc7231#section-8.1.3,
mongoose.c:   * Therefore, if Content-Length is not specified and methods are
mongoose.c:   * if it is HTTP request, and Content-Length is not set,
mongoose.c:  if (hm->body.len == (size_t) ~0 && is_req &&
mongoose.c:      mg_vcasecmp(&hm->method, "PUT") != 0 &&
mongoose.c:      mg_vcasecmp(&hm->method, "POST") != 0) {
mongoose.c:    hm->body.len = 0;
mongoose.c:    hm->message.len = len;
mongoose.c:  for (i = 0; hm->header_names[i].len > 0; i++) {
mongoose.c:    struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i];
mongoose.c:    if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len))
mongoose.c:  size_t n = 0, to_read = 0, left = (size_t)(pd->file.cl - pd->file.sent);
mongoose.c:  if (pd->file.type == DATA_FILE) {
mongoose.c:    struct mbuf *io = &nc->send_mbuf;
mongoose.c:    if (io->len >= MG_MAX_HTTP_SEND_MBUF) {
mongoose.c:      to_read = MG_MAX_HTTP_SEND_MBUF - io->len;
mongoose.c:      n = mg_fread(buf, 1, to_read, pd->file.fp);
mongoose.c:        pd->file.sent += n;
mongoose.c:        DBG(("%p sent %d (total %d)", nc, (int) n, (int) pd->file.sent));
mongoose.c:      /* Rate-limited */
mongoose.c:    if (pd->file.sent >= pd->file.cl) {
mongoose.c:      LOG(LL_DEBUG, ("%p done, %d bytes", nc, (int) pd->file.sent));
mongoose.c:      if (!pd->file.keepalive) nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      mg_http_free_proto_data_file(&pd->file);
mongoose.c:  } else if (pd->file.type == DATA_PUT) {
mongoose.c:    struct mbuf *io = &nc->recv_mbuf;
mongoose.c:    size_t to_write = left <= 0 ? 0 : left < io->len ? (size_t) left : io->len;
mongoose.c:    size_t n = mg_fwrite(io->buf, 1, to_write, pd->file.fp);
mongoose.c:      pd->file.sent += n;
mongoose.c:    if (n == 0 || pd->file.sent >= pd->file.cl) {
mongoose.c:      if (!pd->file.keepalive) nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      mg_http_free_proto_data_file(&pd->file);
mongoose.c:  else if (pd->cgi.cgi_nc != NULL) {
mongoose.c:    if (pd->cgi.cgi_nc != NULL) {
mongoose.c:      mg_forward(nc, pd->cgi.cgi_nc);
mongoose.c:      nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c: * Parse chunked-encoded buffer. Return 0 if the buffer is not encoded, or
mongoose.c:    n += (s[i] >= '0' && s[i] <= '9') ? s[i] - '0' : tolower(s[i]) - 'a' + 10;
mongoose.c:  body_len = (size_t) pd->chunk.body_len;
mongoose.c:       (n = mg_http_parse_chunk(buf + i, blen - i, &data, &data_len)) > 0;
mongoose.c:    hm->body.len = body_len;
mongoose.c:    memmove(buf + body_len, buf + i, blen - i);
mongoose.c:    memset(buf + body_len + blen - i, 0, i - body_len);
mongoose.c:    nc->recv_mbuf.len -= i - body_len;
mongoose.c:    pd->chunk.body_len = body_len;
mongoose.c:    nc->flags &= ~MG_F_DELETE_CHUNK;
mongoose.c:    mg_call(nc, nc->handler, nc->user_data, MG_EV_HTTP_CHUNK, hm);
mongoose.c:    if (nc->flags & MG_F_DELETE_CHUNK) {
mongoose.c:      memmove(buf, buf + body_len, blen - i);
mongoose.c:      nc->recv_mbuf.len -= body_len;
mongoose.c:      hm->body.len = 0;
mongoose.c:      pd->chunk.body_len = 0;
mongoose.c:      hm->message.len =
mongoose.c:          (size_t) pd->chunk.body_len + blen - i + (hm->body.p - hm->message.p);
mongoose.c:  ep = pd->endpoints;
mongoose.c:    if ((matched = mg_match_prefix_n(ep->uri_pattern, *uri_path)) != -1) {
mongoose.c:    ep = ep->next;
mongoose.c:  hm->body.len = c->recv_mbuf.len - req_len;
mongoose.c:  c->flags &= ~MG_F_DELETE_CHUNK;
mongoose.c:  mg_call(c, c->handler, c->user_data, MG_EV_HTTP_CHUNK, hm);
mongoose.c:  if (c->flags & MG_F_DELETE_CHUNK) c->recv_mbuf.len = req_len;
mongoose.c:  struct mbuf *io = &nc->recv_mbuf;
mongoose.c:  const int is_req = (nc->listener != NULL);
mongoose.c:    if (pd->cgi.cgi_nc != NULL) {
mongoose.c:      pd->cgi.cgi_nc->user_data = NULL;
mongoose.c:      pd->cgi.cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    if (pd->mp_stream.boundary != NULL) {
mongoose.c:      mp.status = -1;
mongoose.c:      mp.var_name = pd->mp_stream.var_name;
mongoose.c:      mp.file_name = pd->mp_stream.file_name;
mongoose.c:      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),
mongoose.c:              nc->user_data, MG_EV_HTTP_PART_END, &mp);
mongoose.c:      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),
mongoose.c:              nc->user_data, MG_EV_HTTP_MULTIPART_REQUEST_END, &mp);
mongoose.c:        if (io->len > 0 &&
mongoose.c:            (req_len = mg_parse_http(io->buf, io->len, hm, is_req)) > 0) {
mongoose.c:      * For HTTP messages without Content-Length, always send HTTP message
mongoose.c:      hm->message.len = io->len;
mongoose.c:      hm->body.len = io->buf + io->len - hm->body.p;
mongoose.c:    pd->rcvd = 0;
mongoose.c:  if (pd->file.fp != NULL) {
mongoose.c:  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);
mongoose.c:    pd->rcvd += *(int *) ev_data;
mongoose.c:    if (pd->mp_stream.boundary != NULL) {
mongoose.c:    req_len = mg_parse_http(io->buf, io->len, hm, is_req);
mongoose.c:        (s = mg_get_http_header(hm, "Transfer-Encoding")) != NULL &&
mongoose.c:      mg_handle_chunked(nc, hm, io->buf + req_len, io->len - req_len);
mongoose.c:    if (req_len > 0 && (s = mg_get_http_header(hm, "Content-Type")) != NULL &&
mongoose.c:        s->len >= 9 && strncmp(s->p, "multipart", 9) == 0) {
mongoose.c:         (req_len == 0 && io->len >= MG_MAX_HTTP_REQUEST_SIZE))) {
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    else if (nc->listener == NULL &&
mongoose.c:             mg_get_http_header(hm, "Sec-WebSocket-Accept")) {
mongoose.c:      /* TODO(lsm): check the validity of accept Sec-WebSocket-Accept */
mongoose.c:      nc->proto_handler = mg_ws_handler;
mongoose.c:      nc->flags |= MG_F_IS_WEBSOCKET;
mongoose.c:      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,
mongoose.c:    } else if (nc->listener != NULL &&
mongoose.c:               (vec = mg_get_http_header(hm, "Sec-WebSocket-Key")) != NULL) {
mongoose.c:      nc->proto_handler = mg_ws_handler;
mongoose.c:      nc->flags |= MG_F_IS_WEBSOCKET;
mongoose.c:      ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);
mongoose.c:        nc->handler = ep->handler;
mongoose.c:        nc->user_data = ep->user_data;
mongoose.c:      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_REQUEST,
mongoose.c:      if (!(nc->flags & (MG_F_CLOSE_IMMEDIATELY | MG_F_SEND_AND_CLOSE))) {
mongoose.c:        if (nc->send_mbuf.len == 0) {
mongoose.c:        mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,
mongoose.c:    else if (hm->message.len > pd->rcvd) {
mongoose.c:      int trigger_ev = nc->listener ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;
mongoose.c:      mg_sock_addr_to_str(&nc->sa, addr, sizeof(addr),
mongoose.c:      DBG(("%p %s %.*s %.*s", nc, addr, (int) hm->method.len, hm->method.p,
mongoose.c:           (int) hm->uri.len, hm->uri.p));
mongoose.c:      mbuf_remove(io, hm->message.len);
mongoose.c:      pd->rcvd = 0;
mongoose.c:  struct mbuf *io = &nc->recv_mbuf;
mongoose.c:  ct = mg_get_http_header(hm, "Content-Type");
mongoose.c:    /* We need more data - or it isn't multipart mesage */
mongoose.c:  /* Content-type should start with "multipart" */
mongoose.c:  if (ct->len < 9 || strncmp(ct->p, "multipart", 9) != 0) {
mongoose.c:    nc->flags = MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  /* If we reach this place - that is multipart request */
mongoose.c:  if (pd->mp_stream.boundary != NULL) {
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    pd->mp_stream.state = MPS_BEGIN;
mongoose.c:    pd->mp_stream.boundary = strdup(boundary);
mongoose.c:    pd->mp_stream.boundary_len = strlen(boundary);
mongoose.c:    pd->mp_stream.var_name = pd->mp_stream.file_name = NULL;
mongoose.c:    pd->endpoint_handler = nc->handler;
mongoose.c:    ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);
mongoose.c:      pd->endpoint_handler = ep->handler;
mongoose.c:#define CONTENT_DISPOSITION "Content-Disposition: "
mongoose.c:  mp.var_name = pd->mp_stream.var_name;
mongoose.c:  mp.file_name = pd->mp_stream.file_name;
mongoose.c:  mp.user_data = pd->mp_stream.user_data;
mongoose.c:  mg_call(c, pd->endpoint_handler, c->user_data, ev, &mp);
mongoose.c:  pd->mp_stream.user_data = mp.user_data;
mongoose.c:  struct mbuf *io = &c->recv_mbuf;
mongoose.c:  mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA, io->buf,
mongoose.c:                                 pd->mp_stream.prev_io_len);
mongoose.c:  mbuf_remove(io, pd->mp_stream.prev_io_len);
mongoose.c:  pd->mp_stream.prev_io_len = 0;
mongoose.c:  pd->mp_stream.state = MPS_WAITING_FOR_CHUNK;
mongoose.c:  MG_FREE((void *) pd->mp_stream.file_name);
mongoose.c:  pd->mp_stream.file_name = NULL;
mongoose.c:  MG_FREE((void *) pd->mp_stream.var_name);
mongoose.c:  pd->mp_stream.var_name = NULL;
mongoose.c:  mg_http_free_proto_data_mp_stream(&pd->mp_stream);
mongoose.c:  pd->mp_stream.state = MPS_FINISHED;
mongoose.c:  struct mbuf *io = &c->recv_mbuf;
mongoose.c:  if (pd->mp_stream.boundary == NULL) {
mongoose.c:    pd->mp_stream.state = MPS_FINALIZE;
mongoose.c:  if ((int) io->len < pd->mp_stream.boundary_len + 2) {
mongoose.c:  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);
mongoose.c:    const char *boundary_end = (boundary + pd->mp_stream.boundary_len);
mongoose.c:    if (io->len - (boundary_end - io->buf) < 4) {
mongoose.c:    if (strncmp(boundary_end, "--\r\n", 4) == 0) {
mongoose.c:      pd->mp_stream.state = MPS_FINALIZE;
mongoose.c:      mbuf_remove(io, (boundary_end - io->buf) + 4);
mongoose.c:      pd->mp_stream.state = MPS_GOT_BOUNDARY;
mongoose.c:  struct mbuf *io = &c->recv_mbuf;
mongoose.c:  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);
mongoose.c:  block_begin = boundary + pd->mp_stream.boundary_len + 2;
mongoose.c:  data_size = io->len - (block_begin - io->buf);
mongoose.c:                    sizeof(CONTENT_DISPOSITION) - 1) == 0) {
mongoose.c:      header.p = block_begin + sizeof(CONTENT_DISPOSITION) - 1;
mongoose.c:      header.len = line_len - sizeof(CONTENT_DISPOSITION) - 1;
mongoose.c:      mg_http_parse_header(&header, "name", var_name, sizeof(var_name) - 2);
mongoose.c:                           sizeof(file_name) - 2);
mongoose.c:      data_size -= line_len;
mongoose.c:      mbuf_remove(io, block_begin - io->buf + 2);
mongoose.c:      if (pd->mp_stream.processing_part != 0) {
mongoose.c:      MG_FREE((void *) pd->mp_stream.file_name);
mongoose.c:      pd->mp_stream.file_name = strdup(file_name);
mongoose.c:      MG_FREE((void *) pd->mp_stream.var_name);
mongoose.c:      pd->mp_stream.var_name = strdup(var_name);
mongoose.c:      pd->mp_stream.state = MPS_WAITING_FOR_CHUNK;
mongoose.c:      pd->mp_stream.processing_part++;
mongoose.c:  pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;
mongoose.c:  struct mbuf *io = &c->recv_mbuf;
mongoose.c:  if ((int) io->len < pd->mp_stream.boundary_len + 6 /* \r\n, --, -- */) {
mongoose.c:  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);
mongoose.c:  if (boundary == NULL && pd->mp_stream.prev_io_len == 0) {
mongoose.c:    pd->mp_stream.prev_io_len = io->len;
mongoose.c:             (int) io->len >
mongoose.c:                 pd->mp_stream.prev_io_len + pd->mp_stream.boundary_len + 4) {
mongoose.c:    pd->mp_stream.state = MPS_GOT_CHUNK;
mongoose.c:    int data_size = (boundary - io->buf - 4);
mongoose.c:    mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA, io->buf, data_size);
mongoose.c:    mbuf_remove(io, (boundary - io->buf));
mongoose.c:    pd->mp_stream.prev_io_len = 0;
mongoose.c:    pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;
mongoose.c:    switch (pd->mp_stream.state) {
mongoose.c:        pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;
mongoose.c:        mbuf_remove(&c->recv_mbuf, c->recv_mbuf.len);
mongoose.c:  nc->proto_handler = mg_http_handler;
mongoose.c:      return "Non-Authoritative Information";
mongoose.c:      return "Multi-Status";
mongoose.c:              "Content-Type: text/html\r\n"
mongoose.c:              "Content-Length: %d\r\n"
mongoose.c:              "Cache-Control: no-cache\r\n"
mongoose.c:    mg_printf(c, "%s", "Transfer-Encoding: chunked\r\n");
mongoose.c:    mg_printf(c, "Content-Length: %" INT64_FMT "\r\n", content_length);
mongoose.c:               "Content-Type: text/plain\r\nConnection: close");
mongoose.c:  nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  snprintf(buf, buf_len, "\"%lx.%" INT64_FMT "\"", (unsigned long) st->st_mtime,
mongoose.c:           (int64_t) st->st_size);
mongoose.c:   * There is no snscanf. Headers are not guaranteed to be NUL-terminated,
mongoose.c:  char *p = (char *) MG_MALLOC(header->len + 1);
mongoose.c:  memcpy(p, header->p, header->len);
mongoose.c:  p[header->len] = '\0';
mongoose.c:  result = sscanf(p, "bytes=%" INT64_FMT "-%" INT64_FMT, a, b);
mongoose.c:  if (mg_stat(path, &st) != 0 || (pd->file.fp = mg_fopen(path, "rb")) == NULL) {
mongoose.c:      /* If range is specified like "400-", set second limit to content len */
mongoose.c:        r2 = cl - 1;
mongoose.c:                 "Content-Range: bytes */%" INT64_FMT "\r\n",
mongoose.c:        cl = r2 - r1 + 1;
mongoose.c:        snprintf(range, sizeof(range), "Content-Range: bytes %" INT64_FMT
mongoose.c:                                       "-%" INT64_FMT "/%" INT64_FMT "\r\n",
mongoose.c:                 r1, r1 + cl - 1, (int64_t) st.st_size);
mongoose.c:        fseeko(pd->file.fp, r1, SEEK_SET);
mongoose.c:        fseek(pd->file.fp, (long) r1, SEEK_SET);
mongoose.c:        pd->file.keepalive = (mg_vcasecmp(conn_hdr, "keep-alive") == 0);
mongoose.c:        pd->file.keepalive = (mg_vcmp(&hm->proto, "HTTP/1.1") == 0);
mongoose.c:     * 2) ESP8266 RTOS SDK newlib vprintf cannot contain a 64bit arg at non-last
mongoose.c:              "Last-Modified: %s\r\n"
mongoose.c:              "Accept-Ranges: bytes\r\n"
mongoose.c:              "Content-Type: %.*s\r\n"
mongoose.c:              "Content-Length: %" SIZE_T_FMT
mongoose.c:              (pd->file.keepalive ? "keep-alive" : "close"), (size_t) cl, range,
mongoose.c:    pd->file.cl = cl;
mongoose.c:    pd->file.type = DATA_FILE;
mongoose.c:  if (mg_match_prefix(opts->ssi_pattern, strlen(opts->ssi_pattern), path) > 0) {
mongoose.c:                     mg_mk_str(opts->extra_headers));
mongoose.c:#define HEXTOI(x) (isdigit(x) ? x - '0' : x - 'W')
mongoose.c:  for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {
mongoose.c:      if (i < src_len - 2 && isxdigit(*(const unsigned char *) (src + i + 1)) &&
mongoose.c:        return -1;
mongoose.c:  dst[j] = '\0'; /* Null-terminate the destination */
mongoose.c:  return i >= src_len ? j : -1;
mongoose.c:   * -1 - src is wrong (NUUL)
mongoose.c:   * -2 - dst is wrong (NULL)
mongoose.c:   * -3 - failed to decode url or dst is to small
mongoose.c:   * -4 - name does not exist
mongoose.c:    len = -2;
mongoose.c:  } else if (buf->p == NULL || name == NULL || buf->len == 0) {
mongoose.c:    len = -1;
mongoose.c:    e = buf->p + buf->len;
mongoose.c:    len = -4;
mongoose.c:    for (p = buf->p; p + name_len < e; p++) {
mongoose.c:      if ((p == buf->p || p[-1] == '&') && p[name_len] == '=' &&
mongoose.c:        s = (const char *) memchr(p, '&', (size_t)(e - p));
mongoose.c:        len = mg_url_decode(p, (size_t)(s - p), dst, dst_len, 1);
mongoose.c:        /* -1 means: failed to decode or dst is too small */
mongoose.c:        if (len == -1) {
mongoose.c:          len = -3;
mongoose.c:        mg_send(nc, buf + j, i - j);
mongoose.c:    mg_send(nc, buf + j, i - j);
mongoose.c:  const char *p, *end = hdr ? hdr->p + hdr->len : NULL, *s = NULL;
mongoose.c:  for (s = hdr->p; s != NULL && s + n < end; s++) {
mongoose.c:    if ((s == hdr->p || s[-1] == ch || s[-1] == ch1 || s[-1] == ';') &&
mongoose.c:      if (len > 0 && s[len - 1] == ',') len--;
mongoose.c:      if (len > 0 && s[len - 1] == ';') len--;
mongoose.c:  if (hdr == NULL) return -1;
mongoose.c:  if (mg_strncmp(*hdr, mg_mk_str("Basic "), 6) != 0) return -1;
mongoose.c:  buf = (char *) MG_MALLOC(hdr->len);
mongoose.c:  cs_base64_decode((unsigned char *) hdr->p + 6, hdr->len, buf, NULL);
mongoose.c:           user_len - 1, pass_len - 1);
mongoose.c:    res = -1;
mongoose.c:  const char *p1 = opts->per_directory_auth_file;
mongoose.c:  const char *p2 = opts->hidden_file_pattern;
mongoose.c:         colon, one, ha2, sizeof(ha2) - 1, NULL);
mongoose.c:  mg_mkmd5resp(method, strlen(method), uri, strlen(uri), ha1, sizeof(ha1) - 1,
mongoose.c:               sizeof(qop) - 1, resp);
mongoose.c:  return now < val || now - val < 3600;
mongoose.c:      hm->method,
mongoose.c:          hm->uri.p,
mongoose.c:          hm->uri.len + (hm->query_string.len ? hm->query_string.len + 1 : 0)),
mongoose.c:   * i.e. each line should be a colon-separated sequence:
mongoose.c:  /* None of the entries in the passwords file matched - return failure */
mongoose.c:      snprintf(buf, sizeof(buf), "%.*s%c%s", (int) (p - path.p), path.p, DIRSEP,
mongoose.c:      n += snprintf(dst + n, dst_len - n, "%s", "&lt;");
mongoose.c:  int64_t fsize = stp->st_size;
mongoose.c:  int is_dir = S_ISDIR(stp->st_mode);
mongoose.c:  strftime(mod, sizeof(mod), "%d-%b-%Y %H:%M", localtime(&stp->st_mtime));
mongoose.c:                       href.p, slash, path, slash, mod, is_dir ? -1 : fsize,
mongoose.c:      if (mg_is_file_hidden((const char *) dp->d_name, opts, 1)) {
mongoose.c:      snprintf(path, sizeof(path), "%s/%s", dir, dp->d_name);
mongoose.c:        func(nc, (const char *) dp->d_name, &st);
mongoose.c:    LOG(LL_DEBUG, ("%p opendir(%s) -> %d", nc, dir, mg_get_errno()));
mongoose.c:      "return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : "
mongoose.c:      "n1 ? parseInt(n2) - parseInt(n1) : "
mongoose.c:      "var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];"
mongoose.c:      "var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); "
mongoose.c:  mg_send_response_line(nc, 200, opts->extra_headers);
mongoose.c:  mg_printf(nc, "%s: %s\r\n%s: %s\r\n\r\n", "Transfer-Encoding", "chunked",
mongoose.c:            "Content-Type", "text/html; charset=utf-8");
mongoose.c:      "<style>th,td {text-align: left; padding-right: 1em; "
mongoose.c:      "font-family: monospace; }</style></head>\n"
mongoose.c:      (int) hm->uri.len, hm->uri.p, sort_js_code, sort_js_code2,
mongoose.c:      (int) hm->uri.len, hm->uri.p);
mongoose.c:  nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c: * comma-separated list of index files `list`.
mongoose.c: * appended to the `path`, stat-ed, and result of `stat()` passed to `stp`.
mongoose.c:  const char *rewrites = opts->url_rewrites;
mongoose.c:  mg_conn_addr_to_str(c, local_port + 1, sizeof(local_port) - 1,
mongoose.c:      mg_printf(c, "Content-Length: 0\r\nLocation: %.*s%.*s\r\n\r\n",
mongoose.c:                (int) b.len, b.p, (int) (hm->proto.p - hm->uri.p - 1),
mongoose.c:                hm->uri.p);
mongoose.c:  if (pd == NULL || pd->reverse_proxy_data.linked_conn == NULL) {
mongoose.c:        mg_http_send_error(pd->reverse_proxy_data.linked_conn, 502, NULL);
mongoose.c:      mg_send(pd->reverse_proxy_data.linked_conn, hm->message.p,
mongoose.c:              hm->message.len);
mongoose.c:      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:              (int) (hm->uri.len - mount.len), hm->uri.p + mount.len);
mongoose.c:  be = mg_connect_http_base(nc->mgr, MG_CB(mg_reverse_proxy_handler, NULL),
mongoose.c:  LOG(LL_DEBUG, ("Proxying %.*s to %s (rule: %.*s)", (int) hm->uri.len,
mongoose.c:                 hm->uri.p, purl, (int) mount.len, mount.p));
mongoose.c:  mg_http_get_proto_data(be)->reverse_proxy_data.linked_conn = nc;
mongoose.c:  mg_http_get_proto_data(nc)->reverse_proxy_data.linked_conn = be;
mongoose.c:  mg_printf(be, "%.*s %.*s HTTP/1.1\r\n", (int) hm->method.len, hm->method.p,
mongoose.c:  for (i = 0; i < MG_MAX_HTTP_HEADERS && hm->header_names[i].len > 0; i++) {
mongoose.c:    struct mg_str hn = hm->header_names[i];
mongoose.c:    struct mg_str hv = hm->header_values[i];
mongoose.c:     * Don't pass chunked transfer encoding to the client because hm->body is
mongoose.c:    if (mg_vcasecmp(&hn, "Transfer-encoding") == 0 &&
mongoose.c:      mg_printf(be, "Content-Length: %" SIZE_T_FMT "\r\n", hm->body.len);
mongoose.c:    /* We don't support proxying Expect: 100-continue. */
mongoose.c:        mg_vcasecmp(&hv, "100-continue") == 0) {
mongoose.c:  mg_send(be, hm->body.p, hm->body.len);
mongoose.c:  const char *rewrites = opts->url_rewrites;
mongoose.c:    if (mg_strncmp(a, hm->uri, a.len) == 0) {
mongoose.c:  const char *cp = hm->uri.p, *cp_end = hm->uri.p + hm->uri.len;
mongoose.c:  remainder->p = NULL;
mongoose.c:  remainder->len = 0;
mongoose.c:    const char *rewrites = opts->url_rewrites;
mongoose.c:        if (hh != NULL && hh->len == a.len - 1 &&
mongoose.c:            mg_ncasecmp(a.p + 1, hh->p, a.len - 1) == 0) {
mongoose.c:        int match_len = mg_match_prefix_n(a, hm->uri);
mongoose.c:          file_uri_start = hm->uri.p + match_len;
mongoose.c:          } else if (*(file_uri_start - 1) == '/') {
mongoose.c:            file_uri_start--;
mongoose.c:      if (opts->dav_document_root != NULL && mg_is_dav_request(&hm->method)) {
mongoose.c:        root.p = opts->dav_document_root;
mongoose.c:        root.len = strlen(opts->dav_document_root);
mongoose.c:        root.p = opts->document_root;
mongoose.c:        root.len = strlen(opts->document_root);
mongoose.c:    char *lp = (char *) MG_MALLOC(root.len + hm->uri.len + 1);
mongoose.c:    char *lp_end = lp + root.len + hm->uri.len + 1;
mongoose.c:    if (*(p - 1) == DIRSEP) p--;
mongoose.c:          if (*(u - 1) == '/') u--;
mongoose.c:        len = mg_url_decode(p + 1, component.len, p + 1, lp_end - p - 1, 0);
mongoose.c:          while (p > ps && *p != DIRSEP) p--;
mongoose.c:          /* No NULs and DIRSEPs in the component (percent-encoded). */
mongoose.c:      remainder->p = u;
mongoose.c:      remainder->len = cp_end - u;
mongoose.c:      ("'%.*s' -> '%s' + '%.*s'", (int) hm->uri.len, hm->uri.p,
mongoose.c:       *local_path ? *local_path : "", (int) remainder->len, remainder->p));
mongoose.c:  return -1;
mongoose.c:  return year / 4 - year / 100 + year / 400;
mongoose.c:/* Parse UTC date-time string, and return the corresponding time_t value. */
mongoose.c:       (sscanf(datetime, "%d-%3s-%d %d:%d:%d", &day, month_str, &year, &hour,
mongoose.c:      year > 1970 && (month = mg_get_month_index(month_str)) != -1) {
mongoose.c:    leap_days = mg_num_leap_years(year) - mg_num_leap_years(1970);
mongoose.c:    year -= 1970;
mongoose.c:    days = year * 365 + days_before_month[month] + (day - 1) + leap_days;
mongoose.c:  if ((hdr = mg_get_http_header(hm, "If-None-Match")) != NULL) {
mongoose.c:  } else if ((hdr = mg_get_http_header(hm, "If-Modified-Since")) != NULL) {
mongoose.c:    return st->st_mtime <= mg_parse_date_string(hdr->p);
mongoose.c:            "WWW-Authenticate: Digest qop=\"auth\", "
mongoose.c:            "Content-Length: 0\r\n\r\n",
mongoose.c:  nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  return mg_vcmp(&hm->method, "MKCOL") == 0 || mg_vcmp(&hm->method, "PUT") == 0;
mongoose.c:  int is_dav = mg_is_dav_request(&hm->method);
mongoose.c:    mg_find_index_file(path, opts->index_files, &index_file, &st);
mongoose.c:      (mg_match_prefix(opts->cgi_file_pattern, strlen(opts->cgi_file_pattern),
mongoose.c:       (int) hm->method.len, hm->method.p, path, exists, is_directory, is_dav,
mongoose.c:  if (is_directory && hm->uri.p[hm->uri.len - 1] != '/' && !is_dav) {
mongoose.c:              "Content-Length: 0\r\n\r\n",
mongoose.c:              (int) hm->uri.len, hm->uri.p);
mongoose.c:  if (path_info->len > 0 && !is_cgi) {
mongoose.c:  if (is_dav && opts->dav_document_root == NULL) {
mongoose.c:                                    opts->auth_domain, opts->global_auth_file,
mongoose.c:                                    opts->auth_domain,
mongoose.c:                                    opts->per_directory_auth_file, 0)) {
mongoose.c:    mg_http_send_digest_auth_request(nc, opts->auth_domain);
mongoose.c:  } else if (!mg_vcmp(&hm->method, "PROPFIND")) {
mongoose.c:  } else if (is_dav && (opts->dav_auth_file == NULL ||
mongoose.c:                        (strcmp(opts->dav_auth_file, "-") != 0 &&
mongoose.c:                                                is_directory, opts->auth_domain,
mongoose.c:                                                opts->dav_auth_file, 1)))) {
mongoose.c:    mg_http_send_digest_auth_request(nc, opts->auth_domain);
mongoose.c:  } else if (!mg_vcmp(&hm->method, "MKCOL")) {
mongoose.c:  } else if (!mg_vcmp(&hm->method, "DELETE")) {
mongoose.c:  } else if (!mg_vcmp(&hm->method, "PUT")) {
mongoose.c:  } else if (!mg_vcmp(&hm->method, "MOVE")) {
mongoose.c:  } else if (!mg_vcmp(&hm->method, "LOCK")) {
mongoose.c:  } else if (!mg_vcmp(&hm->method, "OPTIONS")) {
mongoose.c:    if (strcmp(opts->enable_directory_listing, "yes") == 0) {
mongoose.c:  uint32_t remote_ip = ntohl(*(uint32_t *) &nc->sa.sin.sin_addr);
mongoose.c:    nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  /* Normalize path - resolve "." and ".." (in-place). */
mongoose.c:  if (!mg_normalize_uri_path(&hm->uri, &hm->uri)) {
mongoose.c:  /* Close connection for non-keep-alive requests */
mongoose.c:  if (mg_vcmp(&hm->proto, "HTTP/1.1") != 0 ||
mongoose.c:       mg_vcmp(hdr, "keep-alive") != 0)) {
mongoose.c:    nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      struct mg_str lfn = local_name_fn(nc, mg_mk_str(mp->file_name));
mongoose.c:      mp->user_data = NULL;
mongoose.c:        LOG(LL_ERROR, ("%p Not allowed to upload %s", nc, mp->file_name));
mongoose.c:                  "Content-Type: text/plain\r\n"
mongoose.c:                  mp->file_name);
mongoose.c:        nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      fus->lfn = (char *) MG_MALLOC(lfn.len + 1);
mongoose.c:      memcpy(fus->lfn, lfn.p, lfn.len);
mongoose.c:      fus->lfn[lfn.len] = '\0';
mongoose.c:      if (lfn.p != mp->file_name) MG_FREE((char *) lfn.p);
mongoose.c:          ("%p Receiving file %s -> %s", nc, mp->file_name, fus->lfn));
mongoose.c:      fus->fp = mg_fopen(fus->lfn, "w");
mongoose.c:      if (fus->fp == NULL) {
mongoose.c:                  "Content-Type: text/plain\r\n"
mongoose.c:        LOG(LL_ERROR, ("Failed to open %s: %d\n", fus->lfn, mg_get_errno()));
mongoose.c:        mg_printf(nc, "Failed to open %s: %d\n", fus->lfn, mg_get_errno());
mongoose.c:      mp->user_data = (void *) fus;
mongoose.c:          (struct file_upload_state *) mp->user_data;
mongoose.c:      if (fus == NULL || fus->fp == NULL) break;
mongoose.c:      if (mg_fwrite(mp->data.p, 1, mp->data.len, fus->fp) != mp->data.len) {
mongoose.c:        LOG(LL_ERROR, ("Failed to write to %s: %d, wrote %d", fus->lfn,
mongoose.c:                       mg_get_errno(), (int) fus->num_recd));
mongoose.c:                    "Content-Type: text/plain\r\n"
mongoose.c:                    fus->lfn, (int) fus->num_recd);
mongoose.c:                    "Content-Type: text/plain\r\n"
mongoose.c:          mg_printf(nc, "Failed to write to %s: %d, wrote %d", mp->file_name,
mongoose.c:                    mg_get_errno(), (int) fus->num_recd);
mongoose.c:        fclose(fus->fp);
mongoose.c:        remove(fus->lfn);
mongoose.c:        fus->fp = NULL;
mongoose.c:      fus->num_recd += mp->data.len;
mongoose.c:      LOG(LL_DEBUG, ("%p rec'd %d bytes, %d total", nc, (int) mp->data.len,
mongoose.c:                     (int) fus->num_recd));
mongoose.c:          (struct file_upload_state *) mp->user_data;
mongoose.c:      if (mp->status >= 0 && fus->fp != NULL) {
mongoose.c:        LOG(LL_DEBUG, ("%p Uploaded %s (%s), %d bytes", nc, mp->file_name,
mongoose.c:                       fus->lfn, (int) fus->num_recd));
mongoose.c:                  "Content-Type: text/plain\r\n"
mongoose.c:                  "Ok, %s - %d bytes.\r\n",
mongoose.c:                  mp->file_name, (int) fus->num_recd);
mongoose.c:        LOG(LL_ERROR, ("Failed to store %s (%s)", mp->file_name, fus->lfn));
mongoose.c:         * mp->status < 0 means connection was terminated, so no reason to send
mongoose.c:      if (fus->fp != NULL) fclose(fus->fp);
mongoose.c:      MG_FREE(fus->lfn);
mongoose.c:      mp->user_data = NULL;
mongoose.c:      nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  if (query.len > 0) path->len += query.len + 1;
mongoose.c:              (int) host->len, host->p, port_i);
mongoose.c:     * In order to maintain backward compatibility, use a faux-SSL with no
mongoose.c:  mg_printf(nc, "%s %.*s HTTP/1.1\r\nHost: %.*s\r\nContent-Length: %" SIZE_T_FMT
mongoose.c:            (int) (path.p - host.p), host.p, strlen(post_data), (int) auth.len,
mongoose.c:  static const char cd[] = "Content-Disposition: ";
mongoose.c:  size_t hl, bl, n, ll, pos, cdl = sizeof(cd) - 1;
mongoose.c:  if (buf[0] != '-' || buf[1] != '-' || buf[2] == '\n') return 0;
mongoose.c:  for (n = bl; (ll = mg_get_line_len(buf + n, hl - n)) > 0; n += ll) {
mongoose.c:      header.len = ll - (cdl + 2);
mongoose.c:  for (pos = hl; pos + (bl - 2) < buf_len; pos++) {
mongoose.c:    if (buf[pos] == '-' && !strncmp(buf, &buf[pos], bl - 2)) {
mongoose.c:      if (data_len != NULL) *data_len = (pos - 2) - hl;
mongoose.c:  new_ep->uri_pattern = mg_strdup(mg_mk_str(uri_path));
mongoose.c:    new_ep->auth_domain = strdup(opts.auth_domain);
mongoose.c:    new_ep->auth_file = strdup(opts.auth_file);
mongoose.c:  new_ep->handler = handler;
mongoose.c:  new_ep->user_data = opts.user_data;
mongoose.c:  new_ep->next = pd->endpoints;
mongoose.c:  pd->endpoints = new_ep;
mongoose.c:  void *user_data = nc->user_data;
mongoose.c:        mg_http_get_endpoint_handler(nc->listener, &hm->uri);
mongoose.c:      if (!mg_http_is_authorized(hm, hm->uri, 0 /* is_directory */,
mongoose.c:                                 ep->auth_domain, ep->auth_file,
mongoose.c:        mg_http_send_digest_auth_request(nc, ep->auth_domain);
mongoose.c:      pd->endpoint_handler = ep->handler;
mongoose.c:      user_data = ep->user_data;
mongoose.c:  mg_call(nc, pd->endpoint_handler ? pd->endpoint_handler : nc->handler,
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  while (!stop && mg_wait_until_ready(tp->s, 1) &&
mongoose.c:         (n = recv(tp->s, buf, sizeof(buf), 0)) > 0) {
mongoose.c:    if (n == -1 && GetLastError() == WSAEWOULDBLOCK) continue;
mongoose.c:      if (!WriteFile(tp->hPipe, buf + sent, n - sent, &k, 0)) stop = 1;
mongoose.c:  CloseHandle(tp->hPipe);
mongoose.c:  while (!stop && ReadFile(tp->hPipe, buf, sizeof(buf), &n, NULL)) {
mongoose.c:      if (mg_wait_until_ready(tp->s, 0) &&
mongoose.c:          (k = send(tp->s, buf + sent, n - sent, 0)) <= 0)
mongoose.c:  CloseHandle(tp->hPipe);
mongoose.c:  shutdown(tp->s, 2);  // Without this, IO thread may get truncated data
mongoose.c:  closesocket(tp->s);
mongoose.c:    tp->s = sock;
mongoose.c:    tp->hPipe = hPipe;
mongoose.c:    buf[sizeof(buf) - 1] = '\0';
mongoose.c:  DBG(("CGI command: [%ls] -> %p", wcmd, pi.hProcess));
mongoose.c:     * with one exception of SIGCHLD. According to POSIX.1-2001 and Linux's
mongoose.c:  char *added = block->buf + block->len;
mongoose.c:  space = sizeof(block->buf) - (block->len + 2);
mongoose.c:        block->nvars < (int) ARRAY_SIZE(block->vars) - 2) {
mongoose.c:      block->vars[block->nvars++] = added;
mongoose.c:      block->len += n + 1;
mongoose.c:  blk->len = blk->nvars = 0;
mongoose.c:  blk->nc = nc;
mongoose.c:    mg_sock_to_str(nc->sock, buf, sizeof(buf), 3);
mongoose.c:  mg_addenv(blk, "SERVER_ROOT=%s", opts->document_root);
mongoose.c:  mg_addenv(blk, "DOCUMENT_ROOT=%s", opts->document_root);
mongoose.c:  mg_addenv(blk, "REQUEST_METHOD=%.*s", (int) hm->method.len, hm->method.p);
mongoose.c:  mg_addenv(blk, "REQUEST_URI=%.*s%s%.*s", (int) hm->uri.len, hm->uri.p,
mongoose.c:            hm->query_string.len == 0 ? "" : "?", (int) hm->query_string.len,
mongoose.c:            hm->query_string.p);
mongoose.c:  s = hm->uri.p + hm->uri.len - path_info->len - 1;
mongoose.c:    mg_addenv(blk, "SCRIPT_NAME=%.*s/%s", (int) (s - hm->uri.p), hm->uri.p,
mongoose.c:    mg_addenv(blk, "SCRIPT_NAME=%.*s", (int) (s - hm->uri.p + 1), hm->uri.p);
mongoose.c:  if (path_info != NULL && path_info->len > 0) {
mongoose.c:    mg_addenv(blk, "PATH_INFO=%.*s", (int) path_info->len, path_info->p);
mongoose.c:    mg_addenv(blk, "PATH_TRANSLATED=%.*s", (int) path_info->len, path_info->p);
mongoose.c:  mg_addenv(blk, "HTTPS=%s", (nc->flags & MG_F_SSL ? "on" : "off"));
mongoose.c:  if ((h = mg_get_http_header((struct http_message *) hm, "Content-Type")) !=
mongoose.c:    mg_addenv(blk, "CONTENT_TYPE=%.*s", (int) h->len, h->p);
mongoose.c:  if (hm->query_string.len > 0) {
mongoose.c:    mg_addenv(blk, "QUERY_STRING=%.*s", (int) hm->query_string.len,
mongoose.c:              hm->query_string.p);
mongoose.c:  if ((h = mg_get_http_header((struct http_message *) hm, "Content-Length")) !=
mongoose.c:    mg_addenv(blk, "CONTENT_LENGTH=%.*s", (int) h->len, h->p);
mongoose.c:  for (i = 0; hm->header_names[i].len > 0; i++) {
mongoose.c:    p = mg_addenv(blk, "HTTP_%.*s=%.*s", (int) hm->header_names[i].len,
mongoose.c:                  hm->header_names[i].p, (int) hm->header_values[i].len,
mongoose.c:                  hm->header_values[i].p);
mongoose.c:    /* Convert variable name into uppercase, and change - to _ */
mongoose.c:      if (*p == '-') *p = '_';
mongoose.c:  blk->vars[blk->nvars++] = NULL;
mongoose.c:  blk->buf[blk->len++] = '\0';
mongoose.c:  void *user_data = cgi_nc->user_data;
mongoose.c:    cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      if (nc->flags & MG_F_HTTP_CGI_PARSE_HEADERS) {
mongoose.c:        struct mbuf *io = &cgi_nc->recv_mbuf;
mongoose.c:        int len = mg_http_get_request_len(io->buf, io->len);
mongoose.c:        if (len < 0 || io->len > MG_MAX_HTTP_REQUEST_SIZE) {
mongoose.c:          cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:          mg_http_parse_headers(io->buf, io->buf + io->len, io->len, &hm);
mongoose.c:            mg_printf(nc, "HTTP/1.1 %.*s\r\n", (int) h->len, h->p);
mongoose.c:        nc->flags &= ~MG_F_HTTP_CGI_PARSE_HEADERS;
mongoose.c:      if (!(nc->flags & MG_F_HTTP_CGI_PARSE_HEADERS)) {
mongoose.c:      mg_http_free_proto_data_cgi(&mg_http_get_proto_data(nc)->cgi);
mongoose.c:      nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:    snprintf(dir, sizeof(dir), "%.*s", (int) (p - prog), prog);
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  if (mg_start_process(opts->cgi_interpreter, prog, blk.buf, blk.vars, dir,
mongoose.c:    size_t n = nc->recv_mbuf.len - (hm->message.len - hm->body.len);
mongoose.c:        mg_add_sock(nc->mgr, fds[0], mg_cgi_ev_handler MG_UD_ARG(nc));
mongoose.c:    cgi_pd->cgi.cgi_nc = cgi_nc;
mongoose.c:    cgi_pd->cgi.cgi_nc->user_data = nc;
mongoose.c:    nc->flags |= MG_F_HTTP_CGI_PARSE_HEADERS;
mongoose.c:    if (n > 0 && n < nc->recv_mbuf.len) {
mongoose.c:      mg_send(cgi_pd->cgi.cgi_nc, hm->body.p, n);
mongoose.c:    mbuf_remove(&nc->recv_mbuf, nc->recv_mbuf.len);
mongoose.c:  if (d->cgi_nc != NULL) {
mongoose.c:    d->cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    d->cgi_nc->user_data = NULL;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:    snprintf(path, sizeof(path), "%s/%s", opts->document_root, file_name);
mongoose.c:    snprintf(path + strlen(path), sizeof(path) - strlen(path), "%s", file_name);
mongoose.c:    if (mg_match_prefix(opts->ssi_pattern, strlen(opts->ssi_pattern), path) >
mongoose.c: * <!--#directive parameter=value parameter=value -->
mongoose.c:  static const struct mg_str btag = MG_MK_STR("<!--#");
mongoose.c:    if (in_ssi_tag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {
mongoose.c:      size_t i = len - 2;
mongoose.c:      /* Trim closing --> */
mongoose.c:      buf[i--] = '\0';
mongoose.c:        buf[i--] = '\0';
mongoose.c:        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL,
mongoose.c:        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL_CTX, &cctx);
mongoose.c:      } else if (len == (int) sizeof(buf) - 2) {
mongoose.c:    mg_send_response_line(nc, 200, opts->extra_headers);
mongoose.c:              "Content-Type: %.*s\r\n"
mongoose.c:    nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  time_t t = stp->st_mtime; /* store in local variable for NDK compile */
mongoose.c:            name_esc.p, S_ISDIR(stp->st_mode) ? "<d:collection/>" : "",
mongoose.c:            (int64_t) stp->st_size, mtime);
mongoose.c:      "HTTP/1.1 207 Multi-Status\r\n"
mongoose.c:      "Content-Type: text/xml; charset=utf-8\r\n\r\n"
mongoose.c:      "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
mongoose.c:  if (S_ISDIR(stp->st_mode) &&
mongoose.c:      strcmp(opts->enable_directory_listing, "yes") != 0) {
mongoose.c:    mg_send(nc, header, sizeof(header) - 1);
mongoose.c:    snprintf(uri, sizeof(uri), "%.*s", (int) hm->uri.len, hm->uri.p);
mongoose.c:    if (S_ISDIR(stp->st_mode) && (depth == NULL || mg_vcmp(depth, "0") != 0)) {
mongoose.c:    mg_send(nc, footer, sizeof(footer) - 1);
mongoose.c:    nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:      "HTTP/1.1 207 Multi-Status\r\n"
mongoose.c:      "Content-Type: text/xml; charset=utf-8\r\n\r\n"
mongoose.c:      "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
mongoose.c:  nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  if (hm->body.len != (size_t) ~0 && hm->body.len > 0) {
mongoose.c:    if (mg_is_file_hidden((const char *) dp->d_name, opts, 1)) {
mongoose.c:    snprintf(path, sizeof(path), "%s%c%s", dir, '/', dp->d_name);
mongoose.c:    const char *p = (char *) memchr(dest->p, '/', dest->len);
mongoose.c:        (p = (char *) memchr(p + 2, '/', dest->p + dest->len - p)) != NULL) {
mongoose.c:      snprintf(buf, sizeof(buf), "%s%.*s", opts->dav_document_root,
mongoose.c:               (int) (dest->p + dest->len - p), p);
mongoose.c:/* Return -1 on error, 1 on success. */
mongoose.c:      snprintf(buf, sizeof(buf), "%.*s", (int) (s - path), path);
mongoose.c:      buf[sizeof(buf) - 1] = '\0';
mongoose.c:        return -1;
mongoose.c:  const struct mg_str *cl_hdr = mg_get_http_header(hm, "Content-Length");
mongoose.c:  mg_http_free_proto_data_file(&pd->file);
mongoose.c:    mg_printf(nc, "HTTP/1.1 %d OK\r\nContent-Length: 0\r\n\r\n", status_code);
mongoose.c:  } else if (rc == -1) {
mongoose.c:  } else if ((pd->file.fp = mg_fopen(path, "w+b")) == NULL) {
mongoose.c:    const struct mg_str *range_hdr = mg_get_http_header(hm, "Content-Range");
mongoose.c:    pd->file.type = DATA_PUT;
mongoose.c:    mg_set_close_on_exec((sock_t) fileno(pd->file.fp));
mongoose.c:    pd->file.cl = to64(cl_hdr->p);
mongoose.c:      fseeko(pd->file.fp, r1, SEEK_SET);
mongoose.c:      pd->file.cl = r2 > r1 ? r2 - r1 + 1 : pd->file.cl - r1;
mongoose.c:    mg_printf(nc, "HTTP/1.1 %d OK\r\nContent-Length: 0\r\n\r\n", status_code);
mongoose.c:    mbuf_remove(&nc->recv_mbuf, hm->message.len - hm->body.len);
mongoose.c:  if (wsm->flags & 0x8) {
mongoose.c:    mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_CONTROL_FRAME, wsm);
mongoose.c:    mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_FRAME, wsm);
mongoose.c:  return (htd != NULL ? &htd->ws_data : NULL);
mongoose.c:  uint64_t i, data_len = 0, frame_len = 0, buf_len = nc->recv_mbuf.len, len,
mongoose.c:  unsigned char *p = (unsigned char *) nc->recv_mbuf.buf, *buf = p,
mongoose.c:              !(nc->flags & MG_F_WEBSOCKET_NO_DEFRAG);
mongoose.c:      buf_len >= 1 + wsd->reass_len) {
mongoose.c:    buf += 1 + wsd->reass_len;
mongoose.c:    buf_len -= 1 + wsd->reass_len;
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        buf[i + header_len] ^= (buf + header_len - mask_len)[i % 4];
mongoose.c:        wsd->reass_len = 0;
mongoose.c:      memmove(buf, wsm.data, e - wsm.data);
mongoose.c:      wsd->reass_len += wsm.size;
mongoose.c:      nc->recv_mbuf.len -= wsm.data - buf;
mongoose.c:      /* On last fragmented frame - call user handler and remove data */
mongoose.c:        wsm.size = wsd->reass_len;
mongoose.c:        mbuf_remove(&nc->recv_mbuf, 1 + wsd->reass_len);
mongoose.c:        wsd->reass_len = 0;
mongoose.c:      mbuf_remove(&nc->recv_mbuf, (size_t) frame_len); /* Cleanup frame */
mongoose.c:      wsd->reass_len = 0;
mongoose.c:    /* If the frame is not reassembled - client closes and close too */
mongoose.c:      nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  if (nc->listener == NULL) {
mongoose.c:    ctx->mask = mg_ws_random_mask();
mongoose.c:    mg_send(nc, &ctx->mask, sizeof(ctx->mask));
mongoose.c:    ctx->pos = nc->send_mbuf.len;
mongoose.c:    ctx->pos = 0;
mongoose.c:  if (ctx->pos == 0) return;
mongoose.c:  for (i = 0; i < (mbuf->len - ctx->pos); i++) {
mongoose.c:    mbuf->buf[ctx->pos + i] ^= ((char *) &ctx->mask)[i % 4];
mongoose.c:  mg_ws_mask_frame(&nc->send_mbuf, &ctx);
mongoose.c:    nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  mg_ws_mask_frame(&nc->send_mbuf, &ctx);
mongoose.c:    nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);
mongoose.c:        if (nc->flags & MG_F_IS_WEBSOCKET &&
mongoose.c:            now > nc->last_io_time + MG_WEBSOCKET_PING_INTERVAL_SECONDS) {
mongoose.c:  static const char *magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
mongoose.c:  const uint8_t *msgs[2] = {(const uint8_t *) key->p, (const uint8_t *) magic};
mongoose.c:  const size_t msg_lens[2] = {key->len, 36};
mongoose.c:  s = mg_get_http_header(hm, "Sec-WebSocket-Protocol");
mongoose.c:    mg_printf(nc, "Sec-WebSocket-Protocol: %.*s\r\n", (int) s->len, s->p);
mongoose.c:  mg_printf(nc, "Sec-WebSocket-Accept: %s%s", b64_sha, "\r\n\r\n");
mongoose.c:  DBG(("%p %.*s %s", nc, (int) key->len, key->p, b64_sha));
mongoose.c:            "Sec-WebSocket-Version: 13\r\n"
mongoose.c:            "Sec-WebSocket-Key: %s\r\n",
mongoose.c:    int host_len = (int) (path.p - host.p); /* Account for possible :PORT */
mongoose.c:    mg_printf(nc, "Sec-WebSocket-Protocol: %.*s\r\n", (int) protocol.len,
mongoose.c:  v->p = s;
mongoose.c:  v->len = s - v->p;
mongoose.c:  DBG(("[%ls] -> %d", wpath, _wstati64(wpath, st)));
mongoose.c:/* Set close-on-exec bit for a given socket. */
mongoose.c:  is_v6 = sa->sa.sa_family == AF_INET6;
mongoose.c:      addr = &sa->sin.sin_addr;
mongoose.c:      addr = (void *) &sa->sin6.sin6_addr;
mongoose.c:        capacity--;
mongoose.c:    if (inet_ntop(sa->sa.sa_family, addr, start, capacity) == NULL) {
mongoose.c:    char *addr_str = inet_ntoa(sa->sin.sin_addr);
mongoose.c:      strncpy(buf, inet_ntoa(sa->sin.sin_addr), len - 1);
mongoose.c:    if (inet_ntop(AF_INET, (void *) &sa->sin.sin_addr, buf, len - 1) == NULL) {
mongoose.c:    int port = ntohs(sa->sin.sin_port);
mongoose.c:      snprintf(buf + buf_len, len - (buf_len + 1), "%s:%d", (is_v6 ? "]" : ""),
mongoose.c:      if (i > 0) n += snprintf(dst + n, MAX(dst_len - n, 0), "  %s\n", ascii);
mongoose.c:      n += snprintf(dst + n, MAX(dst_len - n, 0), "%04x ", i + offset);
mongoose.c:    if (dst_len - n < 0) {
mongoose.c:    n += snprintf(dst + n, MAX(dst_len - n, 0), " %02x", p[i]);
mongoose.c:  while (i++ % 16) n += snprintf(dst + n, MAX(dst_len - n, 0), "%s", "   ");
mongoose.c:  n += snprintf(dst + n, MAX(dst_len - n, 0), "  %s\n", ascii);
mongoose.c:    len -= n;
mongoose.c:      tag = "<-";
mongoose.c:      tag = "->";
mongoose.c:  if (strcmp(path, "-") == 0) {
mongoose.c:  } else if (strcmp(path, "--") == 0) {
mongoose.c:  /* TODO(mkm) use compiletime check with 4-byte char literal */
mongoose.c:  static const char *dont_escape = "._-$,;~()/";
mongoose.c:  return mg_mk_str_n(mb.buf, mb.len - 1);
mongoose.c:  s->len = getu16(p);
mongoose.c:  s->p = p + 2;
mongoose.c:  return s->p + s->len;
mongoose.c:  if (io->len < 2) return -1;
mongoose.c:  header = io->buf[0];
mongoose.c:  p = io->buf + 1;
mongoose.c:  while ((size_t)(p - io->buf) < io->len) {
mongoose.c:    if (len_len > 4) return -2;
mongoose.c:  if (lc & 0x80 || len > (io->len - (p - io->buf))) {
mongoose.c:    return -1;
mongoose.c:  mm->cmd = cmd;
mongoose.c:  mm->qos = MG_MQTT_GET_QOS(header);
mongoose.c:      p = scanto(p, &mm->protocol_name);
mongoose.c:      if (p > end - 4) return -2;
mongoose.c:      mm->protocol_version = *(uint8_t *) p++;
mongoose.c:      mm->connect_flags = *(uint8_t *) p++;
mongoose.c:      mm->keep_alive_timer = getu16(p);
mongoose.c:      if (p >= end) return -2;
mongoose.c:      p = scanto(p, &mm->client_id);
mongoose.c:      if (p > end) return -2;
mongoose.c:      if (mm->connect_flags & MG_MQTT_HAS_WILL) {
mongoose.c:        if (p >= end) return -2;
mongoose.c:        p = scanto(p, &mm->will_topic);
mongoose.c:      if (mm->connect_flags & MG_MQTT_HAS_WILL) {
mongoose.c:        if (p >= end) return -2;
mongoose.c:        p = scanto(p, &mm->will_message);
mongoose.c:      if (mm->connect_flags & MG_MQTT_HAS_USER_NAME) {
mongoose.c:        if (p >= end) return -2;
mongoose.c:        p = scanto(p, &mm->user_name);
mongoose.c:      if (mm->connect_flags & MG_MQTT_HAS_PASSWORD) {
mongoose.c:        if (p >= end) return -2;
mongoose.c:        p = scanto(p, &mm->password);
mongoose.c:      if (p != end) return -2;
mongoose.c:           (int) len, (int) mm->connect_flags, (int) mm->keep_alive_timer,
mongoose.c:           (int) mm->protocol_name.len, mm->protocol_name.p,
mongoose.c:           (int) mm->client_id.len, mm->client_id.p, (int) mm->will_topic.len,
mongoose.c:           mm->will_topic.p, (int) mm->will_message.len, mm->will_message.p,
mongoose.c:           (int) mm->user_name.len, mm->user_name.p, (int) mm->password.len,
mongoose.c:           mm->password.p));
mongoose.c:      if (end - p < 2) return -2;
mongoose.c:      mm->connack_ret_code = p[1];
mongoose.c:      mm->message_id = getu16(p);
mongoose.c:      p = scanto(p, &mm->topic);
mongoose.c:      if (p > end) return -2;
mongoose.c:      if (mm->qos > 0) {
mongoose.c:        if (end - p < 2) return -2;
mongoose.c:        mm->message_id = getu16(p);
mongoose.c:      mm->payload.p = p;
mongoose.c:      mm->payload.len = end - p;
mongoose.c:      if (end - p < 2) return -2;
mongoose.c:      mm->message_id = getu16(p);
mongoose.c:      mm->payload.p = p;
mongoose.c:      mm->payload.len = end - p;
mongoose.c:  mm->len = end - io->buf;
mongoose.c:  return mm->len;
mongoose.c:  struct mbuf *io = &nc->recv_mbuf;
mongoose.c:  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));
mongoose.c:      if (nc->proto_data == NULL) mg_set_protocol_mqtt(nc);
mongoose.c:          if (len == -1) break; /* not fully buffered */
mongoose.c:          nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        nc->handler(nc, MG_MQTT_EVENT_BASE + mm.cmd, &mm MG_UD_ARG(user_data));
mongoose.c:          (struct mg_mqtt_proto_data *) nc->proto_data;
mongoose.c:      if (pd->keep_alive > 0 && pd->last_control_time > 0 &&
mongoose.c:          (now - pd->last_control_time) > pd->keep_alive) {
mongoose.c:    exp.len -= 1;
mongoose.c:  nc->proto_handler = mqtt_handler;
mongoose.c:  nc->proto_data = MG_CALLOC(1, sizeof(struct mg_mqtt_proto_data));
mongoose.c:  nc->proto_data_destructor = mg_mqtt_proto_data_destructor;
mongoose.c:  struct mg_mqtt_proto_data *pd = (struct mg_mqtt_proto_data *) nc->proto_data;
mongoose.c:  size_t off = nc->send_mbuf.len - len;
mongoose.c:  assert(nc->send_mbuf.len >= len);
mongoose.c:  mbuf_insert(&nc->send_mbuf, off, buf, vlen - buf);
mongoose.c:  pd->last_control_time = mg_time();
mongoose.c:  struct mg_mqtt_proto_data *pd = (struct mg_mqtt_proto_data *) nc->proto_data;
mongoose.c:    pd->keep_alive = opts.keep_alive;
mongoose.c:  size_t old_len = nc->send_mbuf.len;
mongoose.c:                         nc->send_mbuf.len - old_len);
mongoose.c:  size_t old_len = nc->send_mbuf.len;
mongoose.c:                         nc->send_mbuf.len - old_len);
mongoose.c:  unsigned char *buf = (unsigned char *) msg->payload.p + pos;
mongoose.c:  if ((size_t) pos >= msg->payload.len) return -1;
mongoose.c:  topic->len = buf[0] << 8 | buf[1];
mongoose.c:  topic->p = (char *) buf + 2;
mongoose.c:  new_pos = pos + 2 + topic->len + 1;
mongoose.c:  if ((size_t) new_pos > msg->payload.len) return -1;
mongoose.c:  *qos = buf[2 + topic->len];
mongoose.c:  size_t old_len = nc->send_mbuf.len;
mongoose.c:                         nc->send_mbuf.len - old_len);
mongoose.c:/* Amalgamated: #include "mongoose/src/mqtt-server.h" */
mongoose.c:  s->brk = brk;
mongoose.c:  s->subscriptions = NULL;
mongoose.c:  s->num_subscriptions = 0;
mongoose.c:  s->nc = nc;
mongoose.c:  LIST_INSERT_HEAD(&s->brk->sessions, s, link);
mongoose.c:  for (i = 0; i < s->num_subscriptions; i++) {
mongoose.c:    MG_FREE((void *) s->subscriptions[i].topic);
mongoose.c:  MG_FREE(s->subscriptions);
mongoose.c:  LIST_INIT(&brk->sessions);
mongoose.c:  brk->user_data = user_data;
mongoose.c:  s->user_data = nc->user_data;
mongoose.c:  nc->user_data = s;
mongoose.c:  struct mg_mqtt_session *ss = (struct mg_mqtt_session *) nc->user_data;
mongoose.c:       (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;) {
mongoose.c:        (ss->num_subscriptions + num_subs >=
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        ss->subscriptions,
mongoose.c:        sizeof(*ss->subscriptions) * (ss->num_subscriptions + num_subs));
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    ss->subscriptions = te;
mongoose.c:         pos < (int) msg->payload.len &&
mongoose.c:             (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;
mongoose.c:         ss->num_subscriptions++) {
mongoose.c:      te = &ss->subscriptions[ss->num_subscriptions];
mongoose.c:      te->topic = (char *) MG_MALLOC(topic.len + 1);
mongoose.c:      te->qos = qos;
mongoose.c:      memcpy((char *) te->topic, topic.p, topic.len);
mongoose.c:      ((char *) te->topic)[topic.len] = '\0';
mongoose.c:  if (pos == (int) msg->payload.len) {
mongoose.c:    mg_mqtt_suback(nc, qoss, num_subs, msg->message_id);
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    for (i = 0; i < s->num_subscriptions; i++) {
mongoose.c:      if (mg_mqtt_vmatch_topic_expression(s->subscriptions[i].topic,
mongoose.c:                                          msg->topic)) {
mongoose.c:        mg_asprintf(&p, sizeof(buf), "%.*s", (int) msg->topic.len,
mongoose.c:                    msg->topic.p);
mongoose.c:        mg_mqtt_publish(s->nc, p, 0, 0, msg->payload.p, msg->payload.len);
mongoose.c:  if (nc->listener) {
mongoose.c:    brk = (struct mg_mqtt_broker *) nc->listener->user_data;
mongoose.c:    brk = (struct mg_mqtt_broker *) nc->user_data;
mongoose.c:      if (nc->proto_data == NULL) mg_set_protocol_mqtt(nc);
mongoose.c:      nc->user_data = NULL; /* Clear up the inherited pointer to broker */
mongoose.c:      if (nc->user_data == NULL) {
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      if (nc->user_data != NULL) {
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      if (nc->user_data != NULL) {
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      if (nc->listener && nc->user_data != NULL) {
mongoose.c:        mg_mqtt_close_session((struct mg_mqtt_session *) nc->user_data);
mongoose.c:  return s == NULL ? LIST_FIRST(&brk->sessions) : LIST_NEXT(s, link);
mongoose.c:  for (rr = (prev == NULL ? msg->answers : prev + 1);
mongoose.c:       rr - msg->answers < msg->num_answers; rr++) {
mongoose.c:    if (rr->rtype == query) {
mongoose.c:  switch (rr->rtype) {
mongoose.c:        return -1;
mongoose.c:      if (rr->rdata.p + data_len > msg->pkt.p + msg->pkt.len) {
mongoose.c:        return -1;
mongoose.c:      memcpy(data, rr->rdata.p, data_len);
mongoose.c:        return -1; /* LCOV_EXCL_LINE */
mongoose.c:      memcpy(data, rr->rdata.p, data_len);
mongoose.c:      mg_dns_uncompress_name(msg, &rr->rdata, (char *) data, data_len);
mongoose.c:  return -1;
mongoose.c:  header.transaction_id = msg->transaction_id;
mongoose.c:  header.flags = htons(msg->flags);
mongoose.c:  header.num_questions = htons(msg->num_questions);
mongoose.c:  header.num_answers = htons(msg->num_answers);
mongoose.c:  if (msg->num_questions <= 0) return 0;
mongoose.c:  begin = (unsigned char *) msg->pkt.p + sizeof(struct mg_dns_header);
mongoose.c:  last_q = &msg->questions[msg->num_questions - 1];
mongoose.c:  end = (unsigned char *) last_q->name.p + last_q->name.len + 4;
mongoose.c:  return mbuf_append(io, begin, end - begin);
mongoose.c:  size_t pos = io->len;
mongoose.c:    if (s - name > 127) {
mongoose.c:      return -1; /* TODO(mkm) cover */
mongoose.c:    n = s - name;           /* chunk length */
mongoose.c:    len -= n;
mongoose.c:  return io->len - pos;
mongoose.c:  size_t pos = io->len;
mongoose.c:  if (rr->kind == MG_DNS_INVALID_RECORD) {
mongoose.c:    return -1; /* LCOV_EXCL_LINE */
mongoose.c:  if (mg_dns_encode_name(io, name, nlen) == -1) {
mongoose.c:    return -1;
mongoose.c:  u16 = htons(rr->rtype);
mongoose.c:  u16 = htons(rr->rclass);
mongoose.c:  if (rr->kind == MG_DNS_ANSWER) {
mongoose.c:    u32 = htonl(rr->ttl);
mongoose.c:    if (rr->rtype == MG_DNS_CNAME_RECORD) {
mongoose.c:      size_t off = io->len;
mongoose.c:      if ((clen = mg_dns_encode_name(io, (const char *) rdata, rlen)) == -1) {
mongoose.c:        return -1;
mongoose.c:      io->buf[off] = u16 >> 8;
mongoose.c:      io->buf[off + 1] = u16 & 0xff;
mongoose.c:  return io->len - pos;
mongoose.c:  struct mg_dns_resource_record *rr = &msg->questions[0];
mongoose.c:  msg->transaction_id = ++mg_dns_tid;
mongoose.c:  msg->flags = 0x100;
mongoose.c:  msg->num_questions = 1;
mongoose.c:  rr->rtype = query_type;
mongoose.c:  rr->rclass = 1; /* Class: inet */
mongoose.c:  rr->kind = MG_DNS_QUESTION;
mongoose.c:  if (mg_dns_encode_record(&pkt, rr, name, strlen(name), NULL, 0) == -1) {
mongoose.c:  if (!(nc->flags & MG_F_UDP)) {
mongoose.c:  if (data > end - 5) {
mongoose.c:  rr->name.p = (char *) name;
mongoose.c:  rr->name.len = data - name + 1;
mongoose.c:  rr->rtype = data[0] << 8 | data[1];
mongoose.c:  rr->rclass = data[0] << 8 | data[1];
mongoose.c:  rr->kind = reply ? MG_DNS_ANSWER : MG_DNS_QUESTION;
mongoose.c:    if (data >= end - 6) {
mongoose.c:    rr->ttl = (uint32_t) data[0] << 24 | (uint32_t) data[1] << 16 |
mongoose.c:    rr->rdata.p = (char *) data;
mongoose.c:    rr->rdata.len = data_len;
mongoose.c:  msg->pkt.p = buf;
mongoose.c:  msg->pkt.len = len;
mongoose.c:  if (len < (int) sizeof(*header)) return -1;
mongoose.c:  msg->transaction_id = header->transaction_id;
mongoose.c:  msg->flags = ntohs(header->flags);
mongoose.c:  msg->num_questions = ntohs(header->num_questions);
mongoose.c:  if (msg->num_questions > (int) ARRAY_SIZE(msg->questions)) {
mongoose.c:    msg->num_questions = (int) ARRAY_SIZE(msg->questions);
mongoose.c:  msg->num_answers = ntohs(header->num_answers);
mongoose.c:  if (msg->num_answers > (int) ARRAY_SIZE(msg->answers)) {
mongoose.c:    msg->num_answers = (int) ARRAY_SIZE(msg->answers);
mongoose.c:  for (i = 0; i < msg->num_questions; i++) {
mongoose.c:    data = mg_parse_dns_resource_record(data, end, &msg->questions[i], 0);
mongoose.c:    if (data == NULL) return -1;
mongoose.c:  for (i = 0; i < msg->num_answers; i++) {
mongoose.c:    data = mg_parse_dns_resource_record(data, end, &msg->answers[i], 1);
mongoose.c:    if (data == NULL) return -1;
mongoose.c:  const unsigned char *data = (unsigned char *) name->p;
mongoose.c:  const unsigned char *end = (unsigned char *) msg->pkt.p + msg->pkt.len;
mongoose.c:    int leeway = dst_len - (dst - old_dst);
mongoose.c:      uint16_t off = (data[-1] & (~0xc0)) << 8 | data[0];
mongoose.c:      if (off >= msg->pkt.len) {
mongoose.c:      data = (unsigned char *) msg->pkt.p + off;
mongoose.c:    leeway -= chunk_len;
mongoose.c:      return dst - old_dst;
mongoose.c:    *--dst = 0;
mongoose.c:  return dst - old_dst;
mongoose.c:  struct mbuf *io = &nc->recv_mbuf;
mongoose.c:  /* Pass low-level events to the user handler */
mongoose.c:  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));
mongoose.c:      if (!(nc->flags & MG_F_UDP)) {
mongoose.c:        mbuf_remove(&nc->recv_mbuf, 2);
mongoose.c:      if (mg_parse_dns(nc->recv_mbuf.buf, nc->recv_mbuf.len, &msg) == -1) {
mongoose.c:        if (!(nc->flags & MG_F_UDP)) {
mongoose.c:          uint16_t len = htons((uint16_t) io->len);
mongoose.c:        mg_send(nc, io->buf, io->len);
mongoose.c:        nc->handler(nc, MG_DNS_MESSAGE, &msg MG_UD_ARG(user_data));
mongoose.c:      mbuf_remove(io, io->len);
mongoose.c:  nc->proto_handler = dns_handler;
mongoose.c:/* Amalgamated: #include "mongoose/src/dns-server.h" */
mongoose.c:  rep.start = io->len;
mongoose.c:  msg->flags |= 0x8080;
mongoose.c:  msg->num_answers = 0;
mongoose.c:  size_t sent = r->io->len - r->start;
mongoose.c:  mg_dns_insert_header(r->io, r->start, r->msg);
mongoose.c:  if (!(nc->flags & MG_F_UDP)) {
mongoose.c:    mbuf_insert(r->io, r->start, &len, 2);
mongoose.c:  if (&nc->send_mbuf != r->io) {
mongoose.c:    mg_send(nc, r->io->buf + r->start, r->io->len - r->start);
mongoose.c:    r->io->len = r->start;
mongoose.c:  struct mg_dns_message *msg = (struct mg_dns_message *) reply->msg;
mongoose.c:  struct mg_dns_resource_record *ans = &msg->answers[msg->num_answers];
mongoose.c:  if (msg->num_answers >= MG_MAX_DNS_ANSWERS) {
mongoose.c:    return -1; /* LCOV_EXCL_LINE */
mongoose.c:    mg_dns_uncompress_name(msg, &question->name, rname, sizeof(rname) - 1);
mongoose.c:  ans->kind = MG_DNS_ANSWER;
mongoose.c:  ans->rtype = rtype;
mongoose.c:  ans->ttl = ttl;
mongoose.c:  if (mg_dns_encode_record(reply->io, ans, name, strlen(name), rdata,
mongoose.c:                           rdata_len) == -1) {
mongoose.c:    return -1; /* LCOV_EXCL_LINE */
mongoose.c:  msg->num_answers++;
mongoose.c: * Return 0 if OK, -1 if error
mongoose.c:  int ret = -1;
mongoose.c:    ret = -1;
mongoose.c:    for (ret = -1, i = 0; 1; i++) {
mongoose.c:        /* %S will convert wchar_t -> char */
mongoose.c:    ret = -1;
mongoose.c:    for (ret = -1; fgets(line, sizeof(line), fp) != NULL;) {
mongoose.c:    return -1;
mongoose.c:        usa->sin.sin_addr.s_addr = htonl(a << 24 | b << 16 | c << 8 | d);
mongoose.c:  return -1;
mongoose.c:  void *user_data = nc->user_data;
mongoose.c:      if (req->retries > req->max_retries) {
mongoose.c:        req->err = MG_RESOLVE_EXCEEDED_RETRY_COUNT;
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      if (first || now - req->last_time >= req->timeout) {
mongoose.c:        mg_send_dns_query(nc, req->name, req->query);
mongoose.c:        req->last_time = now;
mongoose.c:        req->retries++;
mongoose.c:      if (mg_parse_dns(nc->recv_mbuf.buf, *(int *) data, msg) == 0 &&
mongoose.c:          msg->num_answers > 0) {
mongoose.c:        req->callback(msg, req->data, MG_RESOLVE_OK);
mongoose.c:        nc->user_data = NULL;
mongoose.c:        req->err = MG_RESOLVE_NO_ANSWERS;
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      nc->flags &= ~MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      mbuf_remove(&nc->send_mbuf, nc->send_mbuf.len);
mongoose.c:      req->err = MG_RESOLVE_TIMEOUT;
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        mg_sock_addr_to_str(&nc->sa, addr, sizeof(addr), MG_SOCK_STRINGIFY_IP);
mongoose.c:        LOG(LL_ERROR, ("Failed to resolve '%s', server %s", req->name, addr));
mongoose.c:        req->callback(NULL, req->data, req->err);
mongoose.c:        nc->user_data = NULL;
mongoose.c:    nameserver = mgr->nameserver;
mongoose.c:    return -1;
mongoose.c:  strncpy(req->name, name, sizeof(req->name));
mongoose.c:  req->query = query;
mongoose.c:  req->callback = cb;
mongoose.c:  req->data = data;
mongoose.c:  req->max_retries = opts.max_retries ? opts.max_retries : 2;
mongoose.c:  req->timeout = opts.timeout ? opts.timeout : 5;
mongoose.c:                                        sizeof(dns_server_buff)) != -1) {
mongoose.c:    return -1;
mongoose.c:  dns_nc->user_data = req;
mongoose.c:  MG_FREE((char *) mgr->nameserver);
mongoose.c:  mgr->nameserver = NULL;
mongoose.c:    mgr->nameserver = strdup(nameserver);
mongoose.c: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.c:  while (cm->options != NULL) {
mongoose.c:    struct mg_coap_option *next = cm->options->next;
mongoose.c:    MG_FREE(cm->options);
mongoose.c:    cm->options = next;
mongoose.c:  new_option->number = number;
mongoose.c:  new_option->value.p = value;
mongoose.c:  new_option->value.len = len;
mongoose.c:  if (cm->options == NULL) {
mongoose.c:    cm->options = cm->optiomg_tail = new_option;
mongoose.c:    if (cm->optiomg_tail->number <= new_option->number) {
mongoose.c:      cm->optiomg_tail = cm->optiomg_tail->next = new_option;
mongoose.c:      struct mg_coap_option *current_opt = cm->options;
mongoose.c:        if (current_opt->number > new_option->number) {
mongoose.c:        current_opt = current_opt->next;
mongoose.c:        prev_opt->next = new_option;
mongoose.c:        new_option->next = current_opt;
mongoose.c:        new_option->next = cm->options;
mongoose.c:        cm->options = new_option;
mongoose.c:  if (io->len < sizeof(uint32_t)) {
mongoose.c:    cm->flags |= MG_COAP_NOT_ENOUGH_DATA;
mongoose.c:   * Version (Ver):  2-bit unsigned integer.  Indicates the CoAP version
mongoose.c:    cm->flags |= MG_COAP_IGNORE;
mongoose.c:   * Type (T):  2-bit unsigned integer.  Indicates if this message is of
mongoose.c:   * type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or
mongoose.c:  cm->msg_type = ((uint8_t) *ptr & 0x30) >> 4;
mongoose.c:  cm->flags |= MG_COAP_MSG_TYPE_FIELD;
mongoose.c:   * Token Length (TKL):  4-bit unsigned integer.  Indicates the length of
mongoose.c:   * the variable-length Token field (0-8 bytes).  Lengths 9-15 are
mongoose.c:  cm->token.len = *ptr & 0x0F;
mongoose.c:  if (cm->token.len > 8) {
mongoose.c:    cm->flags |= MG_COAP_FORMAT_ERROR;
mongoose.c:   * Code:  8-bit unsigned integer, split into a 3-bit class (most
mongoose.c:   * significant bits) and a 5-bit detail (least significant bits)
mongoose.c:  cm->code_class = (uint8_t) *ptr >> 5;
mongoose.c:  cm->code_detail = *ptr & 0x1F;
mongoose.c:  cm->flags |= (MG_COAP_CODE_CLASS_FIELD | MG_COAP_CODE_DETAIL_FIELD);
mongoose.c:  /* Message ID:  16-bit unsigned integer in network byte order. */
mongoose.c:  cm->msg_id = (uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1);
mongoose.c:  cm->flags |= MG_COAP_MSG_ID_FIELD;
mongoose.c:  if (cm->token.len != 0) {
mongoose.c:    if (ptr + cm->token.len > io->buf + io->len) {
mongoose.c:      cm->flags |= MG_COAP_NOT_ENOUGH_DATA;
mongoose.c:      cm->token.p = ptr;
mongoose.c:      ptr += cm->token.len;
mongoose.c:      cm->flags |= MG_COAP_TOKEN_FIELD;
mongoose.c:     * 13:  An 8-bit unsigned integer follows the initial byte and
mongoose.c:    if (ptr < io->buf + io->len) {
mongoose.c:      ret = -1; /* LCOV_EXCL_LINE */
mongoose.c:     * 14:  A 16-bit unsigned integer in network byte order follows the
mongoose.c:    if (ptr + sizeof(uint8_t) < io->buf + io->len) {
mongoose.c:      ret = -1; /* LCOV_EXCL_LINE */
mongoose.c: * +---------------+---------------+
mongoose.c: * +---------------+---------------+
mongoose.c: * \    Option Delta (extended)    \  0-2 bytes
mongoose.c: * +-------------------------------+
mongoose.c: * / Option Length  (extended)     \  0-2 bytes
mongoose.c: * +-------------------------------+
mongoose.c: * +-------------------------------+
mongoose.c:  if (ptr == io->buf + io->len) {
mongoose.c:  while (ptr < io->buf + io->len && (uint8_t) *ptr != 0xFF) {
mongoose.c:    /* Option Delta:  4-bit unsigned integer */
mongoose.c:    /* Option Length:  4-bit unsigned integer */
mongoose.c:      cm->flags |= MG_COAP_FORMAT_ERROR;
mongoose.c:    if (optinfo_len == -1) {
mongoose.c:      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */
mongoose.c:    if (optinfo_len == -1) {
mongoose.c:      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */
mongoose.c:    if (ptr + option_lenght > io->buf + io->len) {
mongoose.c:      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */
mongoose.c:  if ((cm->flags & MG_COAP_ERROR) != 0) {
mongoose.c:  cm->flags |= MG_COAP_OPTIOMG_FIELD;
mongoose.c:  if (ptr == io->buf + io->len) {
mongoose.c:  if ((ptr = coap_parse_header(io->buf, io, cm)) == NULL) {
mongoose.c:    return cm->flags;
mongoose.c:    return cm->flags;
mongoose.c:    return cm->flags;
mongoose.c:  cm->payload.len = io->len - (ptr - io->buf);
mongoose.c:  if (cm->payload.len != 0) {
mongoose.c:    cm->payload.p = ptr;
mongoose.c:    cm->flags |= MG_COAP_PAYLOAD_FIELD;
mongoose.c:  return cm->flags;
mongoose.c:    *ext = value - 13;
mongoose.c:    *ext = value - 269;
mongoose.c:  if (cm->msg_type > MG_COAP_MSG_MAX) {
mongoose.c:  if (cm->token.len > 8) {
mongoose.c:  if (cm->code_class > 7) {
mongoose.c:  if (cm->code_detail > 31) {
mongoose.c:  *len += cm->token.len;
mongoose.c:  if (cm->payload.len != 0) {
mongoose.c:    *len += cm->payload.len + 1; /* ... + 1; add payload marker */
mongoose.c:  opt = cm->options;
mongoose.c:    *len += coap_get_ext_opt_size(opt->number - prev_opt_number);
mongoose.c:    *len += coap_get_ext_opt_size((uint32_t) opt->value.len);
mongoose.c:    if ((opt->next != NULL && opt->number > opt->next->number) ||
mongoose.c:        opt->value.len > 0xFFFF + 269 ||
mongoose.c:        opt->number - prev_opt_number > 0xFFFF + 269) {
mongoose.c:    *len += opt->value.len;
mongoose.c:    prev_opt_number = opt->number;
mongoose.c:    opt = opt->next;
mongoose.c:  /* saving previous lenght to handle non-empty mbuf */
mongoose.c:  prev_io_len = io->len;
mongoose.c:  ptr = io->buf + prev_io_len;
mongoose.c:  *ptr = (1 << 6) | (cm->msg_type << 4) | (uint8_t)(cm->token.len);
mongoose.c:  *ptr = (cm->code_class << 5) | (cm->code_detail);
mongoose.c:  ptr = coap_add_uint16(ptr, cm->msg_id);
mongoose.c:  if (cm->token.len != 0) {
mongoose.c:    memcpy(ptr, cm->token.p, cm->token.len);
mongoose.c:    ptr += cm->token.len;
mongoose.c:  opt = cm->options;
mongoose.c:        coap_split_opt(opt->number - prev_opt_number, &delta_base, &delta_ext);
mongoose.c:        coap_split_opt((uint32_t) opt->value.len, &length_base, &length_ext);
mongoose.c:    if (opt->value.len != 0) {
mongoose.c:      memcpy(ptr, opt->value.p, opt->value.len);
mongoose.c:      ptr += opt->value.len;
mongoose.c:    prev_opt_number = opt->number;
mongoose.c:    opt = opt->next;
mongoose.c:  if (cm->payload.len != 0) {
mongoose.c:    *ptr = (char) -1;
mongoose.c:    memcpy(ptr, cm->payload.p, cm->payload.len);
mongoose.c:  struct mbuf *io = &nc->recv_mbuf;
mongoose.c:  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));
mongoose.c:        nc->handler(nc, MG_COAP_EVENT_BASE + cm.msg_type,
mongoose.c:      mbuf_remove(io, io->len);
mongoose.c: * Attach built-in CoAP event handler to the given connection.
mongoose.c: * The user-defined event handler will receive following extra events:
mongoose.c: * - MG_EV_COAP_CON
mongoose.c: * - MG_EV_COAP_NOC
mongoose.c: * - MG_EV_COAP_ACK
mongoose.c: * - MG_EV_COAP_RST
mongoose.c:  if ((nc->flags & MG_F_UDP) == 0) {
mongoose.c:    return -1;
mongoose.c:  nc->proto_handler = coap_handler;
mongoose.c:  client->mgr = mgr;
mongoose.c:  client->iface = iface;
mongoose.c:  client->disp_url = dispatcher;
mongoose.c:  client->last_stream_id = 0;
mongoose.c:  client->ssl = ssl;
mongoose.c:  client->disp = NULL;      /* will be set by mg_tun_reconnect */
mongoose.c:  client->listener = NULL;  /* will be set by mg_do_bind */
mongoose.c:  client->reconnect = NULL; /* will be set by mg_tun_reconnect */
mongoose.c:                 frame->type, frame->flags, (unsigned int) frame->stream_id,
mongoose.c:                 (int) frame->body.len));
mongoose.c:    mg_hexdump(frame->body.p, frame->body.len, hex, sizeof(hex) - 1);
mongoose.c:    hex[sizeof(hex) - 1] = '\0';
mongoose.c:  LOG(LL_DEBUG, ("body: '%.*s'", (int) frame->body.len, frame->body.p));
mongoose.c:  for (nc = client->mgr->active_connections; nc != NULL; nc = nc->next) {
mongoose.c:    if (nc->iface == client->iface && !(nc->flags & MG_F_LISTENING)) {
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  void *user_data = nc->user_data;
mongoose.c:      if (hm->resp_code != 200) {
mongoose.c:            ("Tunnel dispatcher reply non-OK status code %d", hm->resp_code));
mongoose.c:      if (mg_tun_parse_frame(wm->data, wm->size, &frame) == -1) {
mongoose.c:        tc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        client->disp = NULL;
mongoose.c:  opts.ssl_cert = client->ssl.ssl_cert;
mongoose.c:  opts.ssl_key = client->ssl.ssl_key;
mongoose.c:  opts.ssl_ca_cert = client->ssl.ssl_ca_cert;
mongoose.c:  if ((dc = mg_connect_ws_opt(client->mgr, MG_CB(mg_tun_client_handler, client),
mongoose.c:                              opts, client->disp_url, MG_TUN_PROTO_NAME,
mongoose.c:        ("Cannot connect to WS server on addr [%s]\n", client->disp_url));
mongoose.c:  client->disp = dc;
mongoose.c:  dc->user_data = client;
mongoose.c:  void *user_data = nc->user_data;
mongoose.c:      if (!(client->listener->flags & MG_F_TUN_DO_NOT_RECONNECT)) {
mongoose.c:  if (client->reconnect == NULL) {
mongoose.c:    client->reconnect = mg_add_sock(client->mgr, INVALID_SOCKET,
mongoose.c:    client->reconnect->user_data = client;
mongoose.c:  client->reconnect->ev_timer_time = mg_time() + timeout;
mongoose.c:  iface->data = client;
mongoose.c:   * `client->disp` is NULL if connection failed
mongoose.c:   * `client->iface is NULL is `mg_find_iface` failed
mongoose.c:  if (client != NULL && client->disp != NULL) {
mongoose.c:    client->disp->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    client->disp->user_data = NULL;
mongoose.c:  if (client != NULL && client->reconnect != NULL) {
mongoose.c:    client->reconnect->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  if (client != NULL && client->iface != NULL) {
mongoose.c:    client->iface->data = NULL;
mongoose.c:  opts.iface = client->iface;
mongoose.c:  lc = mg_bind_opt(client->mgr, ":1234" /* dummy port */,
mongoose.c:  client->listener = lc;
mongoose.c:    return -1;
mongoose.c:  frame->type = *(uint8_t *) (data);
mongoose.c:  frame->flags = *(uint8_t *) ((char *) data + 1);
mongoose.c:  memcpy(&frame->stream_id, (char *) data + 2, sizeof(uint32_t));
mongoose.c:  frame->stream_id = ntohl(frame->stream_id);
mongoose.c:  frame->body.p = (char *) data + header_size;
mongoose.c:  frame->body.len = len - header_size;
mongoose.c:  tmp -= SNTP_TIME_OFFSET;
mongoose.c:  tv->tv_sec = tmp;
mongoose.c:  tv->tv_usec = mg_get_usec(val);
mongoose.c:   * header - 8 bit:
mongoose.c:   * LI (2 bit) - 3 (not in sync), VN (3 bit) - 4 (version),
mongoose.c:   * mode (3 bit) - 3 (client)
mongoose.c:  /* roundloop delay = (T4 - T1) - (T3 - T2) */
mongoose.c:  uint64_t d1 = ((mg_time() + SNTP_TIME_OFFSET) * 1000000) -
mongoose.c:  uint64_t d2 = (mg_get_sec(t3) * 1000000 + mg_get_usec(t3)) -
mongoose.c:  return (d1 > d2) ? d1 - d2 : 0;
mongoose.c:    return -1;
mongoose.c:    return -1;
mongoose.c:    return -1;
mongoose.c:  msg->kiss_of_death = (buf[1] == 0); /* Server asks to not send requests */
mongoose.c:  msg->time = (double) tv.tv_sec + (((double) tv.tv_usec + delay) / 1000000.0);
mongoose.c:  struct mbuf *io = &c->recv_mbuf;
mongoose.c:  c->handler(c, ev, ev_data MG_UD_ARG(user_data));
mongoose.c:      if (mg_sntp_parse_reply(io->buf, io->len, &msg) < 0) {
mongoose.c:        DBG(("Invalid SNTP packet received (%d)", (int) io->len));
mongoose.c:        c->handler(c, MG_SNTP_MALFORMED_REPLY, NULL MG_UD_ARG(user_data));
mongoose.c:        c->handler(c, MG_SNTP_REPLY, (void *) &msg MG_UD_ARG(user_data));
mongoose.c:      mbuf_remove(io, io->len);
mongoose.c:  if ((c->flags & MG_F_UDP) == 0) {
mongoose.c:    return -1;
mongoose.c:  c->proto_handler = mg_sntp_handler;
mongoose.c:  void *user_data = c->user_data;
mongoose.c:        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);
mongoose.c:      if (sd->count <= SNTP_ATTEMPTS) {
mongoose.c:        sd->count++;
mongoose.c:        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);
mongoose.c:        c->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);
mongoose.c:      c->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      mg_call(c, sd->hander, c->user_data, MG_SNTP_REPLY, ev_data);
mongoose.c:      c->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:      c->user_data = NULL;
mongoose.c:  sd->hander = event_handler;
mongoose.c:  c->user_data = sd;
mongoose.c: *  +----+----------+----------+
mongoose.c: *  +----+----------+----------+
mongoose.c: *  +----+----------+----------+
mongoose.c:  struct mbuf *r = &c->recv_mbuf;
mongoose.c:  if (r->buf[0] != MG_SOCKS_VERSION) {
mongoose.c:    c->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  } else if (r->len > 2 && (size_t) r->buf[1] + 2 <= r->len) {
mongoose.c:    for (i = 2; i < r->buf[1] + 2; i++) {
mongoose.c:      if (r->buf[i] == MG_SOCKS_HANDSHAKE_NOAUTH) reply[1] = r->buf[i];
mongoose.c:    mbuf_remove(r, 2 + r->buf[1]);
mongoose.c:    c->flags |= MG_SOCKS_HANDSHAKE_DONE; /* Mark handshake done */
mongoose.c:  struct mg_connection *c2 = (struct mg_connection *) c->user_data;
mongoose.c:    c2->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:    c2->user_data = NULL;
mongoose.c:  c->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  c->user_data = NULL;
mongoose.c:  struct mg_connection *c2 = (struct mg_connection *) c->user_data;
mongoose.c:    mg_send(c2, c->recv_mbuf.buf, c->recv_mbuf.len);
mongoose.c:    mbuf_remove(&c->recv_mbuf, c->recv_mbuf.len);
mongoose.c:    c->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:  struct mg_connection *serv = mg_connect(c->mgr, addr, serv_ev_handler);
mongoose.c:  serv->user_data = c;
mongoose.c:  c->user_data = serv;
mongoose.c: *  +----+-----+-------+------+----------+----------+
mongoose.c: *  +----+-----+-------+------+----------+----------+
mongoose.c: *  +----+-----+-------+------+----------+----------+
mongoose.c:  struct mbuf *r = &c->recv_mbuf;
mongoose.c:  unsigned char *p = (unsigned char *) r->buf;
mongoose.c:  if (r->len < 8) return; /* return if not fully buffered. min DST.ADDR is 2 */
mongoose.c:    if (r->len < (size_t) addr_len + 6) return; /* return if not buffered */
mongoose.c:    if (r->len < (size_t) addr_len + 6) return; /* return if not buffered */
mongoose.c:    if (r->len < (size_t) addr_len + 6) return; /* return if not buffered */
mongoose.c:   *  +----+-----+-------+------+----------+----------+
mongoose.c:   *  +----+-----+-------+------+----------+----------+
mongoose.c:   *  +----+-----+-------+------+----------+----------+
mongoose.c:  mg_send(c, r->buf + 3, addr_len + 1 + 2);
mongoose.c:  c->flags |= MG_SOCKS_CONNECT_DONE; /* Mark ourselves as connected */
mongoose.c:    if (!(c->flags & MG_SOCKS_HANDSHAKE_DONE)) mg_socks5_handshake(c);
mongoose.c:    if (c->flags & MG_SOCKS_HANDSHAKE_DONE &&
mongoose.c:        !(c->flags & MG_SOCKS_CONNECT_DONE)) {
mongoose.c:    if (c->flags & MG_SOCKS_CONNECT_DONE) relay_data(c);
mongoose.c:  c->proto_handler = socks_handler;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  if (*strp == NULL) return -1;
mongoose.c:    if (*strp == NULL) return -1;
mongoose.c:  return -1;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  tp->tv_sec = ticks / 1000;
mongoose.c:  tp->tv_usec = (ticks % 1000) * 1000;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  tp->tv_sec = 0;
mongoose.c:  tp->tv_usec = 0;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:/* Indirect libc interface - same functions, different names. */
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * With SLFS, you have to pre-declare max file size. Yes. Really.
mongoose.c:  fi->size = (size_t) -1;
mongoose.c:      fi->size = SL_FI_FILE_SIZE(sl_fi);
mongoose.c:  fi->fh = slfs_open((_u8 *) pathname, am);
mongoose.c:                 (unsigned int) new_size, (int) fi->fh));
mongoose.c:  if (fi->fh >= 0) {
mongoose.c:    fi->pos = 0;
mongoose.c:    r = set_errno(sl_fs_to_errno(fi->fh));
mongoose.c:  if (fi->fh <= 0) return set_errno(EBADF);
mongoose.c:  _i32 r = sl_FsClose(fi->fh, NULL, NULL, 0);
mongoose.c:  LOG(LL_DEBUG, ("sl_FsClose(%d) = %d", (int) fi->fh, (int) r));
mongoose.c:  s_sl_fds[fd].fh = -1;
mongoose.c:  if (fi->fh <= 0) return set_errno(EBADF);
mongoose.c:  if (fi->pos == fi->size) return 0;
mongoose.c:  _i32 r = sl_FsRead(fi->fh, fi->pos, buf, count);
mongoose.c:  DBG(("sl_FsRead(%d, %d, %d) = %d", (int) fi->fh, (int) fi->pos, (int) count,
mongoose.c:    fi->pos += r;
mongoose.c:  if (fi->fh <= 0) return set_errno(EBADF);
mongoose.c:  _i32 r = sl_FsWrite(fi->fh, fi->pos, (_u8 *) buf, count);
mongoose.c:  DBG(("sl_FsWrite(%d, %d, %d) = %d", (int) fi->fh, (int) fi->pos, (int) count,
mongoose.c:    fi->pos += r;
mongoose.c:    s->st_mode = S_IFREG | 0666;
mongoose.c:    s->st_nlink = 1;
mongoose.c:    s->st_size = SL_FI_FILE_SIZE(sl_fi);
mongoose.c:  if (fi->fh <= 0) return set_errno(EBADF);
mongoose.c:  s->st_mode = 0666;
mongoose.c:  s->st_mode = S_IFREG | 0666;
mongoose.c:  s->st_nlink = 1;
mongoose.c:  s->st_size = fi->size;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  return (e == 0 ? 0 : -1);
mongoose.c:  int fd = -1;
mongoose.c:  int res = -1;
mongoose.c:    st->st_ino = 0;
mongoose.c:    st->st_mode = S_IFDIR | 0777;
mongoose.c:    st->st_nlink = 1;
mongoose.c:    st->st_size = 0;
mongoose.c:  int r = -1;
mongoose.c:      r = fs_spiffs_close(fd - SPIFFS_FD_BASE);
mongoose.c:      r = fs_slfs_close(fd - SLFS_FD_BASE);
mongoose.c:  int r = -1;
mongoose.c:      r = fs_spiffs_lseek(fd - SPIFFS_FD_BASE, offset, whence);
mongoose.c:      r = fs_slfs_lseek(fd - SLFS_FD_BASE, offset, whence);
mongoose.c:  int r = -1;
mongoose.c:      s->st_ino = fd;
mongoose.c:      s->st_mode = S_IFCHR | 0666;
mongoose.c:      r = fs_spiffs_fstat(fd - SPIFFS_FD_BASE, s);
mongoose.c:      r = fs_slfs_fstat(fd - SLFS_FD_BASE, s);
mongoose.c:  int r = -1;
mongoose.c:      r = fs_spiffs_read(fd - SPIFFS_FD_BASE, buf, count);
mongoose.c:      r = fs_slfs_read(fd - SLFS_FD_BASE, buf, count);
mongoose.c:  int r = -1;
mongoose.c:      r = fs_spiffs_write(fd - SPIFFS_FD_BASE, buf, count);
mongoose.c:      r = fs_slfs_write(fd - SLFS_FD_BASE, buf, count);
mongoose.c:  int r = -1;
mongoose.c:  int r = -1;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  res = snprintf(dst, size, "%lu.%lu.%lu.%lu", SL_IPV4_BYTE(in->s_addr, 0),
mongoose.c:                 SL_IPV4_BYTE(in->s_addr, 1), SL_IPV4_BYTE(in->s_addr, 2),
mongoose.c:                 SL_IPV4_BYTE(in->s_addr, 3));
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  if (nc->flags & MG_F_SSL) proto = SL_SEC_SOCKET;
mongoose.c:    nc->err = sock;
mongoose.c:  nc->err = sl_set_ssl_opts(sock, nc);
mongoose.c:  if (nc->err != 0) goto out;
mongoose.c:  nc->err = sl_Connect(sock, &sa->sa, sizeof(sa->sin));
mongoose.c:  DBG(("%p to %s:%d sock %d %d err %d", nc, inet_ntoa(sa->sin.sin_addr),
mongoose.c:       ntohs(sa->sin.sin_port), nc->sock, proto, nc->err));
mongoose.c:    nc->err = sock;
mongoose.c:  nc->err = 0;
mongoose.c:  if (nc->flags & MG_F_SSL) proto = SL_SEC_SOCKET;
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  if (nc->sock == INVALID_SOCKET) return;
mongoose.c:  if (!(nc->flags & MG_F_UDP) || nc->listener == NULL) {
mongoose.c:    sl_Close(nc->sock);
mongoose.c:  nc->sock = INVALID_SOCKET;
mongoose.c:  sock_t sock = sl_Accept(lc->sock, &sa.sa, &sa_len);
mongoose.c:  if (nc->flags & MG_F_SSL) nc->flags |= MG_F_SSL_HANDSHAKE_DONE;
mongoose.c:      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);
mongoose.c:  sock_t sock = sl_Socket(sa->sa.sa_family, type, proto);
mongoose.c:  if ((r = sl_Bind(sock, &sa->sa, sa_len)) < 0) goto clean;
mongoose.c:  struct mbuf *io = &nc->send_mbuf;
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:    n = sl_SendTo(nc->sock, io->buf, io->len, 0, &nc->sa.sa,
mongoose.c:                  sizeof(nc->sa.sin));
mongoose.c:    DBG(("%p %d %d %d %s:%hu", nc, nc->sock, n, errno,
mongoose.c:         inet_ntoa(nc->sa.sin.sin_addr), ntohs(nc->sa.sin.sin_port)));
mongoose.c:    n = (int) sl_Send(nc->sock, io->buf, io->len, 0);
mongoose.c:    DBG(("%p %d bytes -> %d", nc, n, nc->sock));
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  if (conn->recv_mbuf_limit < conn->recv_mbuf.len) return 0;
mongoose.c:  avail = conn->recv_mbuf_limit - conn->recv_mbuf.len;
mongoose.c:  n = (int) sl_Recv(conn->sock, buf,
mongoose.c:  DBG(("%p %d bytes <- %d", conn, n, conn->sock));
mongoose.c:    conn->flags |= MG_F_SEND_AND_CLOSE;
mongoose.c:    conn->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  int n = sl_RecvFrom(nc->sock, buf, MG_UDP_RECV_BUFFER_SIZE, 0,
mongoose.c:  DBG(("%p %d bytes from %s:%d", nc, n, inet_ntoa(nc->sa.sin.sin_addr),
mongoose.c:       ntohs(nc->sa.sin.sin_port)));
mongoose.c:  DBG(("%p fd=%d fd_flags=%d nc_flags=%lu rmbl=%d smbl=%d", nc, nc->sock,
mongoose.c:       fd_flags, nc->flags, (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));
mongoose.c:  if (nc->flags & MG_F_CONNECTING) {
mongoose.c:    if (nc->flags & MG_F_UDP || nc->err != SL_ERROR_BSD_EALREADY) {
mongoose.c:      mg_if_connect_cb(nc, nc->err);
mongoose.c:      /* In SimpleLink, to get status of non-blocking connect() we need to wait
mongoose.c:        nc->err = sl_Connect(nc->sock, &nc->sa.sa, sizeof(nc->sa.sin));
mongoose.c:        DBG(("%p conn res=%d", nc, nc->err));
mongoose.c:        if (nc->err == SL_ERROR_BSD_ESECSNOVERIFY ||
mongoose.c:            nc->err == SL_ERROR_BSD_ESECDATEERROR
mongoose.c:            nc->err == SL_ERROR_BSD_ESECUNKNOWNROOTCA
mongoose.c:          nc->err = 0;
mongoose.c:        if (nc->flags & MG_F_SSL && nc->err == 0) {
mongoose.c:          nc->flags |= MG_F_SSL_HANDSHAKE_DONE;
mongoose.c:        mg_if_connect_cb(nc, nc->err);
mongoose.c:    if (nc->flags & MG_F_UDP) {
mongoose.c:      if (nc->flags & MG_F_LISTENING) {
mongoose.c:  if (!(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {
mongoose.c:    if ((fd_flags & _MG_F_FD_CAN_WRITE) && nc->send_mbuf.len > 0) {
mongoose.c:  DBG(("%p after fd=%d nc_flags=%lu rmbl=%d smbl=%d", nc, nc->sock, nc->flags,
mongoose.c:       (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));
mongoose.c:  nc->sock = sock;
mongoose.c:  DBG(("%p using sl_Select()", iface->mgr));
mongoose.c:  struct mg_mgr *mgr = iface->mgr;
mongoose.c:   * e.g. timer-only "connections".
mongoose.c:  for (nc = mgr->active_connections, num_fds = 0; nc != NULL; nc = tmp) {
mongoose.c:    tmp = nc->next;
mongoose.c:    if (nc->sock != INVALID_SOCKET) {
mongoose.c:      if (!(nc->flags & MG_F_WANT_WRITE) &&
mongoose.c:          nc->recv_mbuf.len < nc->recv_mbuf_limit &&
mongoose.c:          (!(nc->flags & MG_F_UDP) || nc->listener == NULL)) {
mongoose.c:        SL_SOCKET_FD_SET(nc->sock, &read_set);
mongoose.c:        if (max_fd == INVALID_SOCKET || nc->sock > max_fd) max_fd = nc->sock;
mongoose.c:      if (((nc->flags & MG_F_CONNECTING) && !(nc->flags & MG_F_WANT_READ)) ||
mongoose.c:          (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING))) {
mongoose.c:        SL_SOCKET_FD_SET(nc->sock, &write_set);
mongoose.c:        SL_SOCKET_FD_SET(nc->sock, &err_set);
mongoose.c:        if (max_fd == INVALID_SOCKET || nc->sock > max_fd) max_fd = nc->sock;
mongoose.c:    if (nc->ev_timer_time > 0) {
mongoose.c:      if (num_timers == 0 || nc->ev_timer_time < min_timer) {
mongoose.c:        min_timer = nc->ev_timer_time;
mongoose.c:    double timer_timeout_ms = (min_timer - mg_time()) * 1000 + 1 /* rounding */;
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    if (nc->sock != INVALID_SOCKET) {
mongoose.c:            (SL_SOCKET_FD_ISSET(nc->sock, &read_set) &&
mongoose.c:                     (!(nc->flags & MG_F_UDP) || nc->listener == NULL)
mongoose.c:            (SL_SOCKET_FD_ISSET(nc->sock, &write_set) ? _MG_F_FD_CAN_WRITE
mongoose.c:            (SL_SOCKET_FD_ISSET(nc->sock, &err_set) ? _MG_F_FD_ERROR : 0);
mongoose.c:      if (nc->flags & MG_F_UDP && nc->send_mbuf.len > 0) {
mongoose.c:    tmp = nc->next;
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    tmp = nc->next;
mongoose.c:    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||
mongoose.c:        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {
mongoose.c:  if (remote) memcpy(sa, &nc->sa, sizeof(*sa));
mongoose.c:   * We try our best - we'll restart the listeners, but for outgoing
mongoose.c:    if (nc->sock == INVALID_SOCKET) continue; /* Could be a timer */
mongoose.c:    if (nc->flags & MG_F_LISTENING) {
mongoose.c:      DBG(("restarting %p %s:%d", nc, inet_ntoa(nc->sa.sin.sin_addr),
mongoose.c:           ntohs(nc->sa.sin.sin_port)));
mongoose.c:      int res = (nc->flags & MG_F_UDP ? mg_sl_if_listen_udp(nc, &nc->sa)
mongoose.c:                                      : mg_sl_if_listen_tcp(nc, &nc->sa));
mongoose.c:    nc->sock = INVALID_SOCKET;
mongoose.c:    DBG(("terminating %p %s:%d", nc, inet_ntoa(nc->sa.sin.sin_addr),
mongoose.c:         ntohs(nc->sa.sin.sin_port)));
mongoose.c:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:/* clang-format off */
mongoose.c:/* clang-format on */
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  (sizeof(MG_SSL_IF_SIMPLELINK_SLFS_PREFIX) - 1)
mongoose.c:  nc->ssl_if_data = ctx;
mongoose.c:  if (params->cert != NULL || params->key != NULL) {
mongoose.c:    if (params->cert != NULL && params->key != NULL) {
mongoose.c:      ctx->ssl_cert = strdup(params->cert);
mongoose.c:      ctx->ssl_key = strdup(params->key);
mongoose.c:  if (params->ca_cert != NULL && strcmp(params->ca_cert, "*") != 0) {
mongoose.c:    ctx->ssl_ca_cert = strdup(params->ca_cert);
mongoose.c:  if (params->server_name != NULL) {
mongoose.c:    ctx->ssl_server_name = strdup(params->server_name);
mongoose.c:  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:  nc->ssl_if_data = NULL;
mongoose.c:  MG_FREE(ctx->ssl_cert);
mongoose.c:  MG_FREE(ctx->ssl_key);
mongoose.c:  MG_FREE(ctx->ssl_ca_cert);
mongoose.c:  MG_FREE(ctx->ssl_server_name);
mongoose.c:      if (strstr(pem_buf, "-----END ") != NULL) {
mongoose.c:    } else if (strstr(pem_buf, "-----BEGIN ") != NULL) {
mongoose.c:                      (int) (pem_ext - pem_file), pem_file);
mongoose.c:    LOG(LL_DEBUG, ("%s -> %s = %d", pem_file, der_file, result));
mongoose.c:            l - 2 /* including \0 */);
mongoose.c:  const struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;
mongoose.c:    DBG(("%p %s,%s,%s,%s", nc, (ctx->ssl_cert ? ctx->ssl_cert : "-"),
mongoose.c:         (ctx->ssl_key ? ctx->ssl_cert : "-"),
mongoose.c:         (ctx->ssl_ca_cert ? ctx->ssl_ca_cert : "-"),
mongoose.c:         (ctx->ssl_server_name ? ctx->ssl_server_name : "-")));
mongoose.c:    if (ctx->ssl_cert != NULL && ctx->ssl_key != NULL) {
mongoose.c:      char *ssl_cert = sl_pem2der(ctx->ssl_cert);
mongoose.c:      char *ssl_key = sl_pem2der(ctx->ssl_key);
mongoose.c:        LOG(LL_INFO, ("CERTIFICATE_FILE_NAME %s -> %d", ssl_cert, err));
mongoose.c:        LOG(LL_INFO, ("PRIVATE_KEY_FILE_NAME %s -> %d", ssl_key, err));
mongoose.c:        err = -1;
mongoose.c:    if (ctx->ssl_ca_cert != NULL) {
mongoose.c:      if (ctx->ssl_ca_cert[0] != '\0') {
mongoose.c:        char *ssl_ca_cert = sl_pem2der(ctx->ssl_ca_cert);
mongoose.c:          LOG(LL_INFO, ("CA_FILE_NAME %s -> %d", ssl_ca_cert, err));
mongoose.c:          err = -1;
mongoose.c:    if (ctx->ssl_server_name != NULL) {
mongoose.c:                          ctx->ssl_server_name, strlen(ctx->ssl_server_name));
mongoose.c:      DBG(("DOMAIN_NAME_VERIFICATION %s -> %d", ctx->ssl_server_name, err));
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  memcpy((dst)->sin6.sin6_addr.s6_addr, (src)->ip6.addr, \
mongoose.c:         sizeof((dst)->sin6.sin6_addr.s6_addr))
mongoose.c:#define SET_ADDR(dst, src) (dst)->sin.sin_addr.s_addr = ip_2_ip4(src)->addr
mongoose.c:  if (nc->sock == INVALID_SOCKET || nc->flags & MG_F_UDP) {
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  struct tcp_pcb *tpcb = cs->pcb.tcp;
mongoose.c:    tpcb->keep_idle = idle * 1000;
mongoose.c:    tpcb->keep_intvl = interval * 1000;
mongoose.c:    tpcb->keep_cnt = count;
mongoose.c:    tpcb->so_options |= SOF_KEEPALIVE;
mongoose.c:    tpcb->so_options &= ~SOF_KEEPALIVE;
mongoose.c:  DBG(("%p connect to %s:%u = %d", nc, IPADDR_NTOA(ipX_2_ip(&tpcb->remote_ip)),
mongoose.c:       tpcb->remote_port, err));
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  cs->err = err;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  cs->pcb.tcp = NULL; /* Has already been deallocated */
mongoose.c:  if (nc->flags & MG_F_CONNECTING) {
mongoose.c:    cs->err = err;
mongoose.c:  DBG(("%p %p %u %d", nc, tpcb, (p != NULL ? p->tot_len : 0), err));
mongoose.c:    if (nc != NULL && !(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (p->next != NULL) {
mongoose.c:    struct pbuf *q = p->next;
mongoose.c:    for (; q != NULL; q = q->next) pbuf_ref(q);
mongoose.c:  if (cs->rx_chain == NULL) {
mongoose.c:    cs->rx_offset = 0;
mongoose.c:  } else if (pbuf_clen(cs->rx_chain) >= 4) {
mongoose.c:    struct pbuf *np = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (nc->flags & MG_F_SSL) {
mongoose.c:    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {
mongoose.c:  while (cs->rx_chain != NULL) {
mongoose.c:    struct pbuf *seg = cs->rx_chain;
mongoose.c:    size_t len = (seg->len - cs->rx_offset);
mongoose.c:    pbuf_copy_partial(seg, data, len, cs->rx_offset);
mongoose.c:    cs->rx_offset += len;
mongoose.c:    if (cs->rx_offset == cs->rx_chain->len) {
mongoose.c:      cs->rx_chain = pbuf_dechain(cs->rx_chain);
mongoose.c:      cs->rx_offset = 0;
mongoose.c:  if (nc->send_mbuf.len > 0) {
mongoose.c:    mg_lwip_mgr_schedule_poll(nc->mgr);
mongoose.c:  DBG(("%p %p %u %p %p", nc, tpcb, num_sent, tpcb->unsent, tpcb->unacked));
mongoose.c:  if ((nc->flags & MG_F_SEND_AND_CLOSE) && !(nc->flags & MG_F_WANT_WRITE) &&
mongoose.c:      nc->send_mbuf.len == 0 && tpcb->unsent == NULL && tpcb->unacked == NULL) {
mongoose.c:  struct mg_connection *nc = ctx->nc;
mongoose.c:  const union socket_address *sa = ctx->sa;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  cs->pcb.tcp = tpcb;
mongoose.c:  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;
mongoose.c:  u16_t port = ntohs(sa->sin.sin_port);
mongoose.c:  cs->err = TCP_BIND(tpcb, IP_ADDR_ANY, 0 /* any port */);
mongoose.c:  DBG(("%p tcp_bind = %d", nc, cs->err));
mongoose.c:  if (cs->err != ERR_OK) {
mongoose.c:  cs->err = tcp_connect(tpcb, ip, port, mg_lwip_tcp_conn_cb);
mongoose.c:  DBG(("%p tcp_connect %p = %d", nc, tpcb, cs->err));
mongoose.c:  if (cs->err != ERR_OK) {
mongoose.c:  DBG(("%p %s:%u %p %u %u", nc, IPADDR_NTOA(addr), port, p, p->ref, p->len));
mongoose.c:  union socket_address *sa = (union socket_address *) sap->payload;
mongoose.c:  sa->sin.sin_addr.s_addr = ip_2_ip4(addr)->addr;
mongoose.c:  sa->sin.sin_addr.s_addr = addr->addr;
mongoose.c:  sa->sin.sin_port = htons(port);
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (cs->rx_chain == NULL) {
mongoose.c:    cs->rx_chain = p;
mongoose.c:    pbuf_chain(cs->rx_chain, p);
mongoose.c:  if (!cs->recv_pending) {
mongoose.c:    cs->recv_pending = 1;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  while (cs->rx_chain != NULL) {
mongoose.c:    struct pbuf *sap = cs->rx_chain;
mongoose.c:    struct pbuf *p = sap->next;
mongoose.c:    cs->rx_chain = pbuf_dechain(p);
mongoose.c:    size_t data_len = p->len;
mongoose.c:                        (union socket_address *) sap->payload, sap->len);
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  cs->err = UDP_BIND(upcb, IP_ADDR_ANY, 0 /* any port */);
mongoose.c:  DBG(("%p udp_bind %p = %d", nc, upcb, cs->err));
mongoose.c:  if (cs->err == ERR_OK) {
mongoose.c:    cs->pcb.udp = upcb;
mongoose.c:  SET_ADDR(&sa, &tpcb->remote_ip);
mongoose.c:  sa.sin.sin_port = htons(tpcb->remote_port);
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (cs->pcb.tcp == NULL) return;
mongoose.c:  if (cs->lc->flags & MG_F_SSL) {
mongoose.c:    if (mg_ssl_if_conn_accept(nc, cs->lc) != MG_SSL_OK) {
mongoose.c:      tcpip_callback(tcp_close_tcpip, cs->pcb.tcp);
mongoose.c:    mg_lwip_accept_conn(nc, cs->pcb.tcp);
mongoose.c:       IPADDR_NTOA(ipX_2_ip(&newtpcb->remote_ip)), newtpcb->remote_port));
mongoose.c:  lcs = (struct mg_lwip_conn_state *) lc->sock;
mongoose.c:  lpcb = (struct tcp_pcb_listen *) lcs->pcb.tcp;
mongoose.c:  cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  cs->lc = lc;
mongoose.c:  cs->pcb.tcp = newtpcb;
mongoose.c:  struct mg_connection *nc = ctx->nc;
mongoose.c:  union socket_address *sa = ctx->sa;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;
mongoose.c:  u16_t port = ntohs(sa->sin.sin_port);
mongoose.c:  cs->err = TCP_BIND(tpcb, ip, port);
mongoose.c:  DBG(("%p tcp_bind(%s:%u) = %d", nc, IPADDR_NTOA(ip), port, cs->err));
mongoose.c:  if (cs->err != ERR_OK) {
mongoose.c:    ctx->ret = -1;
mongoose.c:  cs->pcb.tcp = tpcb;
mongoose.c:  ctx->ret = 0;
mongoose.c:  struct mg_connection *nc = ctx->nc;
mongoose.c:  union socket_address *sa = ctx->sa;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;
mongoose.c:  u16_t port = ntohs(sa->sin.sin_port);
mongoose.c:  cs->err = UDP_BIND(upcb, ip, port);
mongoose.c:  DBG(("%p udb_bind(%s:%u) = %d", nc, IPADDR_NTOA(ip), port, cs->err));
mongoose.c:  if (cs->err != ERR_OK) {
mongoose.c:    ctx->ret = -1;
mongoose.c:    cs->pcb.udp = upcb;
mongoose.c:    ctx->ret = 0;
mongoose.c:  struct mg_connection *nc = ctx->nc;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  struct tcp_pcb *tpcb = cs->pcb.tcp;
mongoose.c:  size_t len = MIN(tpcb->mss, MIN(ctx->len, tpcb->snd_buf));
mongoose.c:    DBG(("%p no buf avail %u %u %p %p", tpcb, tpcb->snd_buf, tpcb->snd_queuelen,
mongoose.c:         tpcb->unsent, tpcb->unacked));
mongoose.c:    ctx->ret = 0;
mongoose.c:  unsent = (tpcb->unsent != NULL ? tpcb->unsent->len : 0);
mongoose.c:  unacked = (tpcb->unacked != NULL ? tpcb->unacked->len : 0);
mongoose.c:    ctx->ret = 0;
mongoose.c:  len = MIN(len, (TCP_MSS - unsent));
mongoose.c:  cs->err = tcp_write(tpcb, ctx->data, len, TCP_WRITE_FLAG_COPY);
mongoose.c:  unsent = (tpcb->unsent != NULL ? tpcb->unsent->len : 0);
mongoose.c:  unacked = (tpcb->unacked != NULL ? tpcb->unacked->len : 0);
mongoose.c:  DBG(("%p tcp_write %u = %d, %u %u", tpcb, len, cs->err, unsent, unacked));
mongoose.c:  if (cs->err != ERR_OK) {
mongoose.c:    ctx->ret = (cs->err == ERR_MEM ? 0 : -1);
mongoose.c:  ctx->ret = len;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  struct tcp_pcb *tpcb = cs->pcb.tcp;
mongoose.c:    return -1;
mongoose.c:  ctx->ret = udp_sendto(ctx->upcb, ctx->p, ctx->ip, ctx->port);
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (cs->pcb.udp == NULL) {
mongoose.c:    return -1;
mongoose.c:  struct udp_pcb *upcb = cs->pcb.udp;
mongoose.c:  ip_addr_t ip = {.u_addr.ip4.addr = nc->sa.sin.sin_addr.s_addr, .type = 0};
mongoose.c:  ip_addr_t ip = {.addr = nc->sa.sin.sin_addr.s_addr};
mongoose.c:  u16_t port = ntohs(nc->sa.sin.sin_port);
mongoose.c:  memcpy(p->payload, data, len);
mongoose.c:  cs->err = ctx.ret;
mongoose.c:  return (cs->err == ERR_OK ? len : -1);
mongoose.c:  if (nc->sock == INVALID_SOCKET) return;
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:    num_sent = mg_lwip_udp_send(nc, nc->send_mbuf.buf, nc->send_mbuf.len);
mongoose.c:    DBG(("%p mg_lwip_udp_send %u = %d", nc, nc->send_mbuf.len, num_sent));
mongoose.c:    num_sent = mg_lwip_tcp_write(nc, nc->send_mbuf.buf, nc->send_mbuf.len);
mongoose.c:    DBG(("%p mg_lwip_tcp_write %u = %d", nc, nc->send_mbuf.len, num_sent));
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  mg_lwip_mgr_schedule_poll(nc->mgr);
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  mg_lwip_mgr_schedule_poll(nc->mgr);
mongoose.c:  tcp_recved(ctx->tpcb, ctx->len);
mongoose.c:  if (nc->flags & MG_F_UDP) return;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (nc->sock == INVALID_SOCKET || cs->pcb.tcp == NULL) {
mongoose.c:  DBG(("%p %p %u %u", nc, cs->pcb.tcp, len,
mongoose.c:       (cs->rx_chain ? cs->rx_chain->tot_len : 0)));
mongoose.c:  struct tcp_recved_ctx ctx = {.tpcb = cs->pcb.tcp, .len = len};
mongoose.c:  if (!(nc->flags & MG_F_SSL)) {
mongoose.c:  mbuf_trim(&nc->recv_mbuf);
mongoose.c:  cs->nc = nc;
mongoose.c:  nc->sock = (intptr_t) cs;
mongoose.c:  if (nc->sock == INVALID_SOCKET) return;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (!(nc->flags & MG_F_UDP)) {
mongoose.c:    struct tcp_pcb *tpcb = cs->pcb.tcp;
mongoose.c:    while (cs->rx_chain != NULL) {
mongoose.c:      struct pbuf *seg = cs->rx_chain;
mongoose.c:      cs->rx_chain = pbuf_dechain(cs->rx_chain);
mongoose.c:  } else if (nc->listener == NULL) {
mongoose.c:    struct udp_pcb *upcb = cs->pcb.udp;
mongoose.c:  nc->sock = INVALID_SOCKET;
mongoose.c:  if (nc == NULL || nc->sock == INVALID_SOCKET) return;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:    struct udp_pcb *upcb = cs->pcb.udp;
mongoose.c:      memcpy(sa, &nc->sa, sizeof(*sa));
mongoose.c:      sa->sin.sin_port = htons(upcb->local_port);
mongoose.c:      SET_ADDR(sa, &upcb->local_ip);
mongoose.c:    struct tcp_pcb *tpcb = cs->pcb.tcp;
mongoose.c:      memcpy(sa, &nc->sa, sizeof(*sa));
mongoose.c:      sa->sin.sin_port = htons(tpcb->local_port);
mongoose.c:      SET_ADDR(sa, &tpcb->local_ip);
mongoose.c:  nc->sock = sock;
mongoose.c:/* clang-format off */
mongoose.c:/* clang-format on */
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:      (struct mg_ev_mgr_lwip_data *) nc->iface->data;
mongoose.c:  if (md->sig_queue_len >= MG_SIG_QUEUE_LEN) {
mongoose.c:  int end_index = (md->start_index + md->sig_queue_len) % MG_SIG_QUEUE_LEN;
mongoose.c:  md->sig_queue[end_index].sig = sig;
mongoose.c:  md->sig_queue[end_index].nc = nc;
mongoose.c:  md->sig_queue_len++;
mongoose.c:  mg_lwip_mgr_schedule_poll(nc->mgr);
mongoose.c:      (struct mg_ev_mgr_lwip_data *) mgr->ifaces[MG_MAIN_IFACE]->data;
mongoose.c:  while (md->sig_queue_len > 0) {
mongoose.c:    int sig = md->sig_queue[md->start_index].sig;
mongoose.c:    struct mg_connection *nc = md->sig_queue[md->start_index].nc;
mongoose.c:    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:    md->start_index = (md->start_index + 1) % MG_SIG_QUEUE_LEN;
mongoose.c:    md->sig_queue_len--;
mongoose.c:    if (nc->iface == NULL || nc->mgr == NULL) continue;
mongoose.c:        if (cs->err == 0 && (nc->flags & MG_F_SSL) &&
mongoose.c:            !(nc->flags & MG_F_SSL_HANDSHAKE_DONE)) {
mongoose.c:          mg_if_connect_cb(nc, cs->err);
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:        cs->recv_pending = 0;
mongoose.c:        if (nc->flags & MG_F_UDP) {
mongoose.c:  iface->data = MG_CALLOC(1, sizeof(struct mg_ev_mgr_lwip_data));
mongoose.c:  MG_FREE(iface->data);
mongoose.c:  iface->data = NULL;
mongoose.c:      (struct mg_ev_mgr_lwip_data *) nc->iface->data;
mongoose.c:  /* Walk the queue and null-out further signals for this conn. */
mongoose.c:    if (md->sig_queue[i].nc == nc) {
mongoose.c:      md->sig_queue[i].sig = MG_SIG_TOMBSTONE;
mongoose.c:  struct mg_mgr *mgr = iface->mgr;
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:    tmp = nc->next;
mongoose.c:    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||
mongoose.c:        ((nc->flags & MG_F_SEND_AND_CLOSE) && (nc->flags & MG_F_UDP) &&
mongoose.c:         (nc->send_mbuf.len == 0))) {
mongoose.c:    if ((nc->flags & MG_F_SSL) && cs != NULL && cs->pcb.tcp != NULL &&
mongoose.c:        cs->pcb.tcp->state == ESTABLISHED) {
mongoose.c:      if (((nc->flags & MG_F_WANT_WRITE) ||
mongoose.c:           ((nc->send_mbuf.len > 0) &&
mongoose.c:            (nc->flags & MG_F_SSL_HANDSHAKE_DONE))) &&
mongoose.c:          cs->pcb.tcp->snd_buf > 0) {
mongoose.c:        if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {
mongoose.c:          if (!(nc->flags & MG_F_CONNECTING)) mg_lwip_ssl_send(nc);
mongoose.c:      if (cs->rx_chain != NULL || (nc->flags & MG_F_WANT_READ)) {
mongoose.c:        if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {
mongoose.c:          if (!(nc->flags & MG_F_CONNECTING)) mg_lwip_ssl_recv(nc);
mongoose.c:      if (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING)) {
mongoose.c:    if (nc->sock != INVALID_SOCKET &&
mongoose.c:        !(nc->flags & (MG_F_UDP | MG_F_LISTENING)) && cs->pcb.tcp != NULL &&
mongoose.c:        cs->pcb.tcp->unsent != NULL) {
mongoose.c:      tcpip_callback(tcp_output_tcpip, cs->pcb.tcp);
mongoose.c:    if (nc->ev_timer_time > 0) {
mongoose.c:      if (num_timers == 0 || nc->ev_timer_time < min_timer) {
mongoose.c:        min_timer = nc->ev_timer_time;
mongoose.c:    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:    if (nc->ev_timer_time > 0) {
mongoose.c:      if (num_timers == 0 || nc->ev_timer_time < min_timer) {
mongoose.c:        min_timer = nc->ev_timer_time;
mongoose.c:    if (nc->send_mbuf.len > 0
mongoose.c:        || (nc->flags & MG_F_WANT_WRITE)
mongoose.c:      if (nc->flags & MG_F_UDP) {
mongoose.c:        can_send = (cs->pcb.udp != NULL);
mongoose.c:        can_send = (cs->pcb.tcp != NULL && cs->pcb.tcp->snd_buf > 0);
mongoose.c:    double timer_timeout_ms = (min_timer - now) * 1000 + 1 /* rounding */;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  int server_side = (nc->listener != NULL);
mongoose.c:  if (nc->flags & MG_F_CLOSE_IMMEDIATELY) return;
mongoose.c:  DBG(("%p %lu %d %d", nc, nc->flags, server_side, res));
mongoose.c:      nc->flags |= MG_F_WANT_WRITE;
mongoose.c:      cs->err = 0;
mongoose.c:       * Nothing to do in particular, we are callback-driven.
mongoose.c:      nc->flags &= ~MG_F_WANT_READ;
mongoose.c:      cs->err = 0;
mongoose.c:      cs->err = res;
mongoose.c:    cs->err = 0;
mongoose.c:    nc->flags &= ~MG_F_WANT_WRITE;
mongoose.c:    nc->flags |= (MG_F_SSL_HANDSHAKE_DONE | MG_F_WANT_READ);
mongoose.c:      mg_lwip_accept_conn(nc, cs->pcb.tcp);
mongoose.c:  if (nc->sock == INVALID_SOCKET) {
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  int len = cs->last_ssl_write_size;
mongoose.c:    len = MIN(MG_LWIP_SSL_IO_SIZE, nc->send_mbuf.len);
mongoose.c:  int ret = mg_ssl_if_write(nc, nc->send_mbuf.buf, len);
mongoose.c:    cs->last_ssl_write_size = 0;
mongoose.c:    cs->last_ssl_write_size = len;
mongoose.c:    nc->flags &= ~MG_F_WANT_WRITE;
mongoose.c:    nc->flags |= MG_F_WANT_WRITE;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  if (nc->flags & MG_F_CONNECTING) return;
mongoose.c:  while (nc->recv_mbuf.len < MG_LWIP_SSL_RECV_MBUF_LIMIT) {
mongoose.c:    DBG(("%p %p SSL_read %u = %d", nc, cs->rx_chain, MG_LWIP_SSL_IO_SIZE, ret));
mongoose.c:        nc->flags |= MG_F_WANT_WRITE;
mongoose.c:         * Nothing to do in particular, we are callback-driven.
mongoose.c:        nc->flags &= ~MG_F_WANT_READ;
mongoose.c:        cs->err = 0;
mongoose.c:  int ret = mg_lwip_tcp_write(cs->nc, buf, len);
mongoose.c:  DBG(("%p mg_lwip_tcp_write %u = %d", cs->nc, len, ret));
mongoose.c:  struct pbuf *seg = cs->rx_chain;
mongoose.c:    DBG(("%u - nothing to read", len));
mongoose.c:  size_t seg_len = (seg->len - cs->rx_offset);
mongoose.c:  DBG(("%u %u %u %u", len, cs->rx_chain->len, seg_len, cs->rx_chain->tot_len));
mongoose.c:  pbuf_copy_partial(seg, buf, len, cs->rx_offset);
mongoose.c:  cs->rx_offset += len;
mongoose.c:  tcp_recved(cs->pcb.tcp, len);
mongoose.c:  if (cs->rx_offset == cs->rx_chain->len) {
mongoose.c:    cs->rx_chain = pbuf_dechain(cs->rx_chain);
mongoose.c:    cs->rx_offset = 0;
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  int ret = mg_lwip_tcp_write(cs->nc, buf, len);
mongoose.c:  LOG(LL_DEBUG, ("%p %d -> %d", nc, len, ret));
mongoose.c:  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;
mongoose.c:  struct pbuf *seg = cs->rx_chain;
mongoose.c:    DBG(("%u - nothing to read", len));
mongoose.c:  size_t seg_len = (seg->len - cs->rx_offset);
mongoose.c:  DBG(("%u %u %u %u", len, cs->rx_chain->len, seg_len, cs->rx_chain->tot_len));
mongoose.c:  pbuf_copy_partial(seg, buf, len, cs->rx_offset);
mongoose.c:  cs->rx_offset += len;
mongoose.c:  if (cs->pcb.tcp != NULL) tcp_recved(cs->pcb.tcp, len);
mongoose.c:  if (cs->rx_offset == cs->rx_chain->len) {
mongoose.c:    cs->rx_chain = pbuf_dechain(cs->rx_chain);
mongoose.c:    cs->rx_offset = 0;
mongoose.c:  LOG(LL_DEBUG, ("%p <- %d", nc, (int) len));
mongoose.c:    return -1;
mongoose.c:    st->st_mode |= _S_IFREG;
mongoose.c:      return -1;
mongoose.c:    st->st_size = GetFileSize(h, NULL);
mongoose.c:    st->st_mtime = (uint32_t)((((uint64_t) ftime.dwLowDateTime +
mongoose.c:                               10000000.0) -
mongoose.c:    st->st_mode |= _S_IFDIR;
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.c:  if (nc->sock == INVALID_SOCKET) return;
mongoose.c:  if (!(nc->flags & MG_F_UDP)) {
mongoose.c:    TCPIP_TCP_Close((TCP_SOCKET) nc->sock);
mongoose.c:  } else if (nc->listener == NULL) {
mongoose.c:    TCPIP_UDP_Close((UDP_SOCKET) nc->sock);
mongoose.c:  nc->sock = INVALID_SOCKET;
mongoose.c:  nc->sock = TCPIP_UDP_ServerOpen(
mongoose.c:      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4
mongoose.c:      ntohs(sa->sin.sin_port),
mongoose.c:      sa->sin.sin_addr.s_addr == 0 ? 0 : (IP_MULTI_ADDRESS *) &sa->sin);
mongoose.c:  if (nc->sock == INVALID_SOCKET) {
mongoose.c:    return -1;
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  mbuf_append(&nc->send_mbuf, buf, len);
mongoose.c:  nc->sock = TCPIP_TCP_ServerOpen(
mongoose.c:      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4
mongoose.c:      ntohs(sa->sin.sin_port),
mongoose.c:      sa->sin.sin_addr.s_addr == 0 ? 0 : (IP_MULTI_ADDRESS *) &sa->sin);
mongoose.c:  memcpy(&nc->sa, sa, sizeof(*sa));
mongoose.c:  if (nc->sock == INVALID_SOCKET) {
mongoose.c:    return -1;
mongoose.c:  nc->sock = lc->sock;
mongoose.c:  nc->flags &= ~MG_F_LISTENING;
mongoose.c:  if (!TCPIP_TCP_SocketInfoGet((TCP_SOCKET) nc->sock, &si)) {
mongoose.c:  return mg_pic32_if_listen_tcp(lc, &lc->sa) >= 0;
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:            (UDP_SOCKET) nc->sock,
mongoose.c:            nc->sa.sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4
mongoose.c:            ntohs(nc->sa.sin.sin_port), (IP_MULTI_ADDRESS *) &nc->sa.sin)) {
mongoose.c:      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    bytes_written = TCPIP_UDP_TxPutIsReady((UDP_SOCKET) nc->sock, 0);
mongoose.c:    if (bytes_written >= nc->send_mbuf.len) {
mongoose.c:      if (TCPIP_UDP_ArrayPut((UDP_SOCKET) nc->sock,
mongoose.c:                             (uint8_t *) nc->send_mbuf.buf,
mongoose.c:                             nc->send_mbuf.len) != nc->send_mbuf.len) {
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    bytes_written = TCPIP_TCP_FifoTxFreeGet((TCP_SOCKET) nc->sock);
mongoose.c:      if (bytes_written > nc->send_mbuf.len) {
mongoose.c:        bytes_written = nc->send_mbuf.len;
mongoose.c:      if (TCPIP_TCP_ArrayPut((TCP_SOCKET) nc->sock,
mongoose.c:                             (uint8_t *) nc->send_mbuf.buf,
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  if (nc->flags & MG_F_UDP) {
mongoose.c:    bytes_read = TCPIP_UDP_GetIsReady((UDP_SOCKET) nc->sock);
mongoose.c:        (nc->recv_mbuf_limit == -1 ||
mongoose.c:         nc->recv_mbuf.len + bytes_read < nc->recv_mbuf_limit)) {
mongoose.c:      if (TCPIP_UDP_ArrayGet((UDP_SOCKET) nc->sock, buf, bytes_read) !=
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:    bytes_read = TCPIP_TCP_GetIsReady((TCP_SOCKET) nc->sock);
mongoose.c:      if (nc->recv_mbuf_limit != -1 &&
mongoose.c:          nc->recv_mbuf_limit - nc->recv_mbuf.len > bytes_read) {
mongoose.c:        bytes_read = nc->recv_mbuf_limit - nc->recv_mbuf.len;
mongoose.c:      if (TCPIP_TCP_ArrayGet((TCP_SOCKET) nc->sock, buf, bytes_read) !=
mongoose.c:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.c:  struct mg_mgr *mgr = iface->mgr;
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    tmp = nc->next;
mongoose.c:    if (nc->flags & MG_F_CONNECTING) {
mongoose.c:      if (nc->flags & MG_F_UDP ||
mongoose.c:          TCPIP_TCP_IsConnected((TCP_SOCKET) nc->sock)) {
mongoose.c:    } else if (nc->flags & MG_F_LISTENING) {
mongoose.c:      if (TCPIP_TCP_IsConnected((TCP_SOCKET) nc->sock)) {
mongoose.c:      if (nc->send_mbuf.len != 0) {
mongoose.c:      if (nc->recv_mbuf_limit == -1 ||
mongoose.c:          nc->recv_mbuf.len < nc->recv_mbuf_limit) {
mongoose.c:  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {
mongoose.c:    tmp = nc->next;
mongoose.c:    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||
mongoose.c:        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {
mongoose.c:  nc->sock = sock;
mongoose.c:  nc->sock = TCPIP_TCP_ClientOpen(
mongoose.c:      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4
mongoose.c:      ntohs(sa->sin.sin_port), (IP_MULTI_ADDRESS *) &sa->sin);
mongoose.c:  nc->err = (nc->sock == INVALID_SOCKET) ? -1 : 0;
mongoose.c:  nc->sock = TCPIP_UDP_ClientOpen(IP_ADDRESS_TYPE_ANY, 0, NULL);
mongoose.c:  nc->err = (nc->sock == INVALID_SOCKET) ? -1 : 0;
mongoose.c:/* clang-format off */
mongoose.c:/* clang-format on */
mongoose.h: * Copyright (c) 2004-2013 Sergey Lyubka
mongoose.h: * Copyright (c) 2013-2015 Cesanta Software Limited
mongoose.h: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.h:/* https://stackoverflow.com/questions/16647819/timegm-cross-platform */
mongoose.h:/* Enable 64-bit file offsets */
mongoose.h: * We require strtoll, and if your embedded pre-c99 compiler lacks one, please
mongoose.h:#define INVALID_SOCKET (-1)
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:#define fileno(x) -1
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:#define INVALID_SOCKET (-1)
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:#define INVALID_SOCKET (-1)
mongoose.h:#define fileno(x) -1
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:#define INVALID_SOCKET (-1)
mongoose.h:#define fileno(x) -1
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * non-unix platforms.
mongoose.h:#define INVALID_SOCKET (-1)
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h: * When compiling for nRF5x chips with arm-none-eabi-gcc, it has BYTE_ORDER
mongoose.h:#define INVALID_SOCKET (-1)
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:/* Sub-second granularity time(). */
mongoose.h: * Similar to (non-standard) timegm, converts broken-down time into the number
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:  { str_literal, sizeof(str_literal) - 1 }
mongoose.h: * Cross-platform version of `strcmp()` where where first string is
mongoose.h: * Cross-platform version of `strncasecmp()` where first string is
mongoose.h:/* Creates a copy of s (heap-allocated). */
mongoose.h: * Creates a copy of s (heap-allocated).
mongoose.h: * Resulting string is NUL-terminated (but NUL is not included in len).
mongoose.h: * Simple string -> int64 conversion routine.
mongoose.h: * Cross-platform version of `strncasecmp()`.
mongoose.h: * Cross-platform version of `strcasecmp()`.
mongoose.h: * The purpose of this is to avoid malloc-ing if generated strings are small.
mongoose.h: * `eq_val` will contain zero-length string.
mongoose.h: * Matches 0-terminated string (mg_match_prefix) or string with given length
mongoose.h: * - * matches zero or more characters until a slash character /
mongoose.h: * - ** matches zero or more characters
mongoose.h: * - ? Matches exactly one character which is not a slash /
mongoose.h: * - | or ,  divides alternative patterns
mongoose.h: * - any other character matches itself
mongoose.h: * Match is case-insensitive. Returns number of bytes matched, or -1 if no
mongoose.h: * mg_match_prefix("a*f", len, "abcdexgh") == -1
mongoose.h: * mg_match_prefix("?*", len, "") == -1
mongoose.h:/* clang-format off */
mongoose.h:/*-
mongoose.h: * This file defines four types of data structures: singly-linked lists,
mongoose.h: * singly-linked tail queues, lists and tail queues.
mongoose.h: * A singly-linked list is headed by a single forward pointer. The elements
mongoose.h: * macro for this purpose for optimum efficiency. A singly-linked list may
mongoose.h: * only be traversed in the forward direction.  Singly-linked lists are ideal
mongoose.h: * A singly-linked tail queue is headed by a pair of pointers, one to the
mongoose.h: * A singly-linked tail queue may only be traversed in the forward direction.
mongoose.h: * Singly-linked tail queues are ideal for applications with large datasets
mongoose.h: * _PREV			-	+	-	+
mongoose.h: * _LAST			-	-	+	+
mongoose.h: * _FOREACH_REVERSE		-	-	-	+
mongoose.h: * _FOREACH_REVERSE_FROM	-	-	-	+
mongoose.h: * _FOREACH_REVERSE_SAFE	-	-	-	+
mongoose.h: * _FOREACH_REVERSE_FROM_SAFE	-	-	-	+
mongoose.h: * _INSERT_BEFORE		-	+	-	+
mongoose.h: * _INSERT_TAIL			-	-	+	+
mongoose.h: * _CONCAT			-	-	+	+
mongoose.h: * _REMOVE_AFTER		+	-	+	-
mongoose.h: * _REMOVE_HEAD			+	-	+	-
mongoose.h:#define	TRASHIT(x)	do {(x) = (void *)-1;} while (0)
mongoose.h:	(head)->trace.prevline = (head)->trace.lastline;		\
mongoose.h:	(head)->trace.prevfile = (head)->trace.lastfile;		\
mongoose.h:	(head)->trace.lastline = __LINE__;				\
mongoose.h:	(head)->trace.lastfile = __FILE__;				\
mongoose.h:	(elem)->trace.prevline = (elem)->trace.lastline;		\
mongoose.h:	(elem)->trace.prevfile = (elem)->trace.lastfile;		\
mongoose.h:	(elem)->trace.lastline = __LINE__;				\
mongoose.h:	(elem)->trace.lastfile = __FILE__;				\
mongoose.h: * Singly-linked List declarations.
mongoose.h: * Singly-linked List functions.
mongoose.h:#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
mongoose.h:#define	SLIST_FIRST(head)	((head)->slh_first)
mongoose.h:#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
mongoose.h:	QMD_SAVELINK(oldnext, (elm)->field.sle_next);			\
mongoose.h: * Singly-linked Tail queue declarations.
mongoose.h: * Singly-linked Tail queue functions.
mongoose.h:		*(head1)->stqh_last = (head2)->stqh_first;		\
mongoose.h:		(head1)->stqh_last = (head2)->stqh_last;		\
mongoose.h:#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
mongoose.h:#define	STAILQ_FIRST(head)	((head)->stqh_first)
mongoose.h:	(head)->stqh_last = &STAILQ_FIRST((head));			\
mongoose.h:		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
mongoose.h:		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
mongoose.h:	*(head)->stqh_last = (elm);					\
mongoose.h:	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
mongoose.h:	    __containerof((head)->stqh_last,			\
mongoose.h:#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
mongoose.h:	QMD_SAVELINK(oldnext, (elm)->field.stqe_next);			\
mongoose.h:		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
mongoose.h:		(head)->stqh_last = &STAILQ_FIRST((head));		\
mongoose.h:	QUEUE_TYPEOF(type) **swap_last = (head1)->stqh_last;		\
mongoose.h:	(head1)->stqh_last = (head2)->stqh_last;			\
mongoose.h:	(head2)->stqh_last = swap_last;					\
mongoose.h:		(head1)->stqh_last = &STAILQ_FIRST(head1);		\
mongoose.h:		(head2)->stqh_last = &STAILQ_FIRST(head2);		\
mongoose.h:	    LIST_FIRST((head))->field.le_prev !=			\
mongoose.h:		panic("Bad list head %p first->prev != head", (head));	\
mongoose.h:	    LIST_NEXT((elm), field)->field.le_prev !=			\
mongoose.h:	     &((elm)->field.le_next))					\
mongoose.h:	     	panic("Bad link elm %p next->prev != elm", (elm));	\
mongoose.h:	if (*(elm)->field.le_prev != (elm))				\
mongoose.h:		panic("Bad link elm %p prev->next != elm", (elm));	\
mongoose.h:#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
mongoose.h:#define	LIST_FIRST(head)	((head)->lh_first)
mongoose.h:		LIST_NEXT((listelm), field)->field.le_prev =		\
mongoose.h:	(elm)->field.le_prev = &LIST_NEXT((listelm), field);		\
mongoose.h:	(elm)->field.le_prev = (listelm)->field.le_prev;		\
mongoose.h:	*(listelm)->field.le_prev = (elm);				\
mongoose.h:	(listelm)->field.le_prev = &LIST_NEXT((elm), field);		\
mongoose.h:		LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
mongoose.h:	(elm)->field.le_prev = &LIST_FIRST((head));			\
mongoose.h:#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
mongoose.h:	((elm)->field.le_prev == &LIST_FIRST((head)) ? NULL :	\
mongoose.h:	    __containerof((elm)->field.le_prev,			\
mongoose.h:	QMD_SAVELINK(oldnext, (elm)->field.le_next);			\
mongoose.h:	QMD_SAVELINK(oldprev, (elm)->field.le_prev);			\
mongoose.h:		LIST_NEXT((elm), field)->field.le_prev = 		\
mongoose.h:		    (elm)->field.le_prev;				\
mongoose.h:	*(elm)->field.le_prev = LIST_NEXT((elm), field);		\
mongoose.h:		swap_tmp->field.le_prev = &LIST_FIRST((head1));		\
mongoose.h:		swap_tmp->field.le_prev = &LIST_FIRST((head2));		\
mongoose.h:	    TAILQ_FIRST((head))->field.tqe_prev !=			\
mongoose.h:		panic("Bad tailq head %p first->prev != head", (head));	\
mongoose.h:	if (*(head)->tqh_last != NULL)					\
mongoose.h:	    	panic("Bad tailq NEXT(%p->tqh_last) != NULL", (head)); 	\
mongoose.h:	    TAILQ_NEXT((elm), field)->field.tqe_prev !=			\
mongoose.h:	     &((elm)->field.tqe_next))					\
mongoose.h:		panic("Bad link elm %p next->prev != elm", (elm));	\
mongoose.h:	if (*(elm)->field.tqe_prev != (elm))				\
mongoose.h:		panic("Bad link elm %p prev->next != elm", (elm));	\
mongoose.h:		*(head1)->tqh_last = (head2)->tqh_first;		\
mongoose.h:		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
mongoose.h:		(head1)->tqh_last = (head2)->tqh_last;			\
mongoose.h:#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
mongoose.h:#define	TAILQ_FIRST(head)	((head)->tqh_first)
mongoose.h:	(head)->tqh_last = &TAILQ_FIRST((head));			\
mongoose.h:		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
mongoose.h:		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
mongoose.h:	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);		\
mongoose.h:	QMD_TRACE_ELEM(&(elm)->field);					\
mongoose.h:	QMD_TRACE_ELEM(&(listelm)->field);				\
mongoose.h:	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
mongoose.h:	*(listelm)->field.tqe_prev = (elm);				\
mongoose.h:	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);		\
mongoose.h:	QMD_TRACE_ELEM(&(elm)->field);					\
mongoose.h:	QMD_TRACE_ELEM(&(listelm)->field);				\
mongoose.h:		TAILQ_FIRST((head))->field.tqe_prev =			\
mongoose.h:		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
mongoose.h:	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
mongoose.h:	QMD_TRACE_ELEM(&(elm)->field);					\
mongoose.h:	(elm)->field.tqe_prev = (head)->tqh_last;			\
mongoose.h:	*(head)->tqh_last = (elm);					\
mongoose.h:	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
mongoose.h:	QMD_TRACE_ELEM(&(elm)->field);					\
mongoose.h:	(*(((struct headname *)((head)->tqh_last))->tqh_last))
mongoose.h:#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
mongoose.h:	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
mongoose.h:	QMD_SAVELINK(oldnext, (elm)->field.tqe_next);			\
mongoose.h:	QMD_SAVELINK(oldprev, (elm)->field.tqe_prev);			\
mongoose.h:		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
mongoose.h:		    (elm)->field.tqe_prev;				\
mongoose.h:		(head)->tqh_last = (elm)->field.tqe_prev;		\
mongoose.h:	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
mongoose.h:	QMD_TRACE_ELEM(&(elm)->field);					\
mongoose.h:	QUEUE_TYPEOF(type) *swap_first = (head1)->tqh_first;		\
mongoose.h:	QUEUE_TYPEOF(type) **swap_last = (head1)->tqh_last;		\
mongoose.h:	(head1)->tqh_first = (head2)->tqh_first;			\
mongoose.h:	(head1)->tqh_last = (head2)->tqh_last;				\
mongoose.h:	(head2)->tqh_first = swap_first;				\
mongoose.h:	(head2)->tqh_last = swap_last;					\
mongoose.h:	if ((swap_first = (head1)->tqh_first) != NULL)			\
mongoose.h:		swap_first->field.tqe_prev = &(head1)->tqh_first;	\
mongoose.h:		(head1)->tqh_last = &(head1)->tqh_first;		\
mongoose.h:	if ((swap_first = (head2)->tqh_first) != NULL)			\
mongoose.h:		swap_first->field.tqe_prev = &(head2)->tqh_first;	\
mongoose.h:		(head2)->tqh_last = &(head2)->tqh_first;		\
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:#ifndef MG_ENABLE_THREADS /* ifdef-ok */
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:  void *data; /* Implementation-specific data */
mongoose.h:  /* Set up a listening TCP socket on a given address. rv = 0 -> ok. */
mongoose.h:  /* Perform interface-related connection initialization. Return 1 on ok. */
mongoose.h:  /* Perform interface-related cleanup on connection before destruction. */
mongoose.h: * This is phase 1 of the two-phase process - MG_EV_ACCEPT will be delivered
mongoose.h:/* Callback invoked by connect methods. err = 0 -> ok, != 0 -> error. */
mongoose.h: * if `own` is true, buf must be heap-allocated and ownership is transferred
mongoose.h: * buf must be heap-allocated and ownership is transferred to the core.
mongoose.h: * Copyright (c) 2014-2016 Cesanta Software Limited
mongoose.h:  MG_SSL_WANT_READ = -1,
mongoose.h:  MG_SSL_WANT_WRITE = -2,
mongoose.h:  MG_SSL_ERROR = -3,
mongoose.h: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.h:#define MG_EV_TIMER 6   /* now >= conn->ev_timer_time. double * */
mongoose.h:  struct mg_connection *listener;    /* Set only for accept()-ed connections */
mongoose.h:  mg_event_handler_t proto_handler; /* Protocol-specific event handler */
mongoose.h:  void *proto_data;                 /* Protocol-specific data */
mongoose.h:  void *user_data;            /* User-specific data */
mongoose.h:  void *mgr_data; /* Implementation-specific event manager's data. */
mongoose.h: * `mgr->user_data` field will be initialised with a `user_data` parameter.
mongoose.h: * De-initialises Mongoose manager.
mongoose.h: * of the connections is IO-ready, `mg_mgr_poll()` triggers the respective
mongoose.h: * that can be, and must be, called from a different (non-IO) thread.
mongoose.h:  /* Colon-delimited list of acceptable cipher suites.
mongoose.h:   * ECDH-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256 (OpenSSL)
mongoose.h:   * TLS-ECDH-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256
mongoose.h:  /* Colon-delimited list of acceptable cipher suites.
mongoose.h:   * ECDH-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256 (OpenSSL)
mongoose.h:   * TLS-ECDH-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256
mongoose.h:   * PSK identity and key. Identity is a NUL-terminated string and key is a hex
mongoose.h:   * string. Key must be either 16 or 32 bytes (32 or 64 hex digits) for AES-128
mongoose.h:   * or AES-256 respectively.
mongoose.h: * IPv6 address (if Mongoose is compiled with `-DMG_ENABLE_IPV6`) or a host
mongoose.h: * NOTE: To enable IPv6 addresses `-DMG_ENABLE_IPV6` should be specified
mongoose.h: * Sends `printf`-style formatted data to the connection.
mongoose.h: * `-DMG_ENABLE_GETADDRINFO`, then `getaddrinfo()` call is used for name
mongoose.h: * `remote_ip` - an IPv4 address to check, in host byte order
mongoose.h: * `acl` - a comma separated list of IP subnets: `x.x.x.x/x` or `x.x.x.x`.
mongoose.h: * prepended by either a - or a + sign. A plus sign means allow, where a
mongoose.h: * minus sign means deny. If a subnet mask is omitted, such as `-1.2.3.4`,
mongoose.h: * `-0.0.0.0/0,+192.168/16` - deny all accesses, only allow 192.168/16 subnet
mongoose.h: * Returns -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.
mongoose.h: * `double` instead of `time_t` to allow for sub-second precision.
mongoose.h: *      c->flags |= MG_F_CLOSE_IMMEDIATELY;
mongoose.h: * A sub-second precision version of time().
mongoose.h: * Returns 0 on success, -1 on error.
mongoose.h: * Assemble URI from parts. Any of the inputs can be NULL or zero-length mg_str.
mongoose.h: * Result is a heap-allocated string (uri->p must be free()d after use).
mongoose.h: * Returns 0 on success, -1 on error.
mongoose.h: * Skips initial delimiter characters. Records first non-delimiter character
mongoose.h: * until a delimiter character or end-of-string is found.
mongoose.h: * `delimiters` is a 0-terminated string containing delimiter characters.
mongoose.h: * Decodes base64-encoded string `s`, `len` into the destination `dst`.
mongoose.h: * Destination is '\0'-terminated.
mongoose.h: * Base64-encode chunk of memory `src`, `src_len` into the destination `dst`.
mongoose.h: * Destination is '\0'-terminated.
mongoose.h: * Performs a 64-bit `stat()` call against a given file.
mongoose.h: * - MG_SOCK_STRINGIFY_IP - print IP address
mongoose.h: * - MG_SOCK_STRINGIFY_PORT - print port number
mongoose.h: * - MG_SOCK_STRINGIFY_REMOTE - print remote peer's IP/port, not local address
mongoose.h: * If compiled with `-DMG_ENABLE_IPV6`, IPv6 addresses are supported.
mongoose.h: * Generates a human-readable hexdump of memory chunk.
mongoose.h: * buffer in `dst`. The generated output is a-la hexdump(1).
mongoose.h: * Generates human-readable hexdump of the data sent or received by the
mongoose.h: * URL-escape the specified string.
mongoose.h: * All non-printable characters are escaped, plus `._-$,;~()/`.
mongoose.h: * Input need not be NUL-terminated, but the returned string is.
mongoose.h: * Returned string is heap-allocated and must be free()'d.
mongoose.h:  struct mg_str body;    /* Message body. 0-length for requests with no body */
mongoose.h:  struct mg_str proto;  /* "HTTP/1.1" -- for both request and response */
mongoose.h:   * Query-string part of the URI. For example, for HTTP request
mongoose.h:  struct mg_str arg; /* The argument passed to the tag: <!-- call arg -->. */
mongoose.h: * Attaches a built-in HTTP event handler to the given connection.
mongoose.h: * The user-defined event handler will receive following extra events:
mongoose.h: * - MG_EV_HTTP_REQUEST: HTTP request has arrived. Parsed HTTP request
mongoose.h: * - MG_EV_HTTP_REPLY: The HTTP reply has arrived. The parsed HTTP reply is
mongoose.h: * - MG_EV_HTTP_CHUNK: The HTTP chunked-encoding chunk has arrived.
mongoose.h: * - MG_EV_WEBSOCKET_HANDSHAKE_REQUEST: server has received the WebSocket
mongoose.h: * - MG_EV_WEBSOCKET_HANDSHAKE_DONE: server has completed the WebSocket
mongoose.h: * - MG_EV_WEBSOCKET_FRAME: new WebSocket frame has arrived. `ev_data` is
mongoose.h: * - MG_EV_HTTP_MULTIPART_REQUEST: Start of the request.
mongoose.h: * - MG_EV_HTTP_PART_BEGIN: Start of a part of a multipart message.
mongoose.h: * - MG_EV_HTTP_PART_DATA: new portion of data from the multipart message.
mongoose.h: * - MG_EV_HTTP_PART_END: End of the current part. var_name, file_name are
mongoose.h: * - MG_EV_HTTP_MULTIPART_REQUEST_END: End of the multipart request.
mongoose.h: * `Sec-WebSocket-Proto` header (NULL to omit), extra_headers` is extra HTTP
mongoose.h: * NUL-temrinated */
mongoose.h: * `url` is a URL to connect to. It must be properly URL-encoded, e.g. have
mongoose.h: * `"User-Agent: my-app\r\n"`.
mongoose.h: * If `protocol` is not NULL, then a `Sec-WebSocket-Protocol` header is sent.
mongoose.h: * - WEBSOCKET_OP_CONTINUE
mongoose.h: * - WEBSOCKET_OP_TEXT
mongoose.h: * - WEBSOCKET_OP_BINARY
mongoose.h: * - WEBSOCKET_OP_CLOSE
mongoose.h: * - WEBSOCKET_OP_PING
mongoose.h: * - WEBSOCKET_OP_PONG
mongoose.h: * - WEBSOCKET_DONT_FIN: Don't set the FIN flag on the frame to be sent.
mongoose.h: * with `printf()`-like semantics.
mongoose.h: * Decodes a URL-encoded string.
mongoose.h: * (`dst`, `dst_len`). If `is_form_url_encoded` is non-zero, then
mongoose.h: * guarantees to NUL-terminate the destination. If destination is too small,
mongoose.h: * then the source string is partially decoded and `-1` is returned.
mongoose.h: * in the buffer `buf`, `buf_size`. Returns 0 if variable not found, non-zero
mongoose.h: * Returns -1 if no Authorization header is found, or if
mongoose.h: * Returns -1 iif the authorization type is not "Basic" or any other error such
mongoose.h: *          while ((n2 = mg_parse_multipart(hm->body.p + n1,
mongoose.h: *                                          hm->body.len - n1,
mongoose.h: * `dst_len`. The destination is always zero-terminated. Returns the length of
mongoose.h: * url-encoded buffer. If destination is too small or an error occured,
mongoose.h:   * Server Side Includes (SSI) is a simple interpreted server-side scripting
mongoose.h:   * In order for a webpage to recognize an SSI-enabled HTML file, the
mongoose.h:   *    &lt;!--#include FILE_TO_INCLUDE --&gt;
mongoose.h:   *    &lt;!--#exec "COMMAND_TO_EXECUTE" --&gt;
mongoose.h:   *    &lt;!--#call COMMAND --&gt;
mongoose.h:   * Note that &lt;!--#include ...> directive supports three path
mongoose.h:   * &lt;!--#include virtual="path" --&gt;  Path is relative to web server root
mongoose.h:   * &lt;!--#include abspath="path" --&gt;  Path is absolute or relative to the
mongoose.h:   * &lt;!--#include file="path" --&gt;,    Path is relative to current document
mongoose.h:   * &lt;!--#include "path" --&gt;
mongoose.h:   * &lt;!--#exec "ls -l" --&gt;
mongoose.h:   * On each occurence of &lt;!--#call COMMAND OPTIONAL_PARAMS> directive,
mongoose.h:   * &lt;!--#call foo --&gt; ... &lt;!--#call bar --&gt;
mongoose.h:   * Comma-separated list of `uri_pattern=url_file_or_directory_path` rewrites.
mongoose.h:   * If passwords file is set to "-", then DAV auth is disabled.
mongoose.h:  /* Set to non-NULL to enable CGI, e.g. **.cgi$|**.php$" */
mongoose.h:   * Comma-separated list of Content-Type overrides for path suffixes, e.g.
mongoose.h:   * ".txt=text/plain; charset=utf-8,.c=text/plain"
mongoose.h:   * Example: to enable CORS, set this to "Access-Control-Allow-Origin: *".
mongoose.h: * non-null, the returned string must be heap-allocated and will be freed by
mongoose.h: *   // fname is user-controlled and needs to be sanitized.
mongoose.h: *  nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.h: *  nc->flags |= MG_F_SEND_AND_CLOSE;
mongoose.h: * to the `nc->send_mbuf` output IO buffer.
mongoose.h: * NOTE: The HTTP header "Transfer-Encoding: chunked" should be sent prior to
mongoose.h: * Sends a printf-formatted HTTP chunk.
mongoose.h: *      mg_send_response_line(nc, 200, "Access-Control-Allow-Origin: *");
mongoose.h: *      Access-Control-Allow-Origin: *\r\n
mongoose.h: * sends one header: either "Content-Length" or "Transfer-Encoding".
mongoose.h: * If `content_length` is negative, then "Transfer-Encoding: chunked" header
mongoose.h: * is sent, otherwise, "Content-Length" header is sent.
mongoose.h: * NOTE: If `Transfer-Encoding` is `chunked`, then message body must be sent
mongoose.h: * Sends a printf-formatted HTTP chunk, escaping HTML tags.
mongoose.h: * `url` is the URL to fetch. It must be properly URL-encoded, e.g. have
mongoose.h: * `"User-Agent: my-app\r\n"`.
mongoose.h: * posted is a form submission, the `Content-Type` header should be set
mongoose.h: *       "Content-Type: application/x-www-form-urlencoded\r\n",
mongoose.h: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.h: * Attaches a built-in MQTT event handler to the given connection.
mongoose.h: * The user-defined event handler will receive following extra events:
mongoose.h: * - MG_EV_MQTT_CONNACK
mongoose.h: * - MG_EV_MQTT_PUBLISH
mongoose.h: * - MG_EV_MQTT_PUBACK
mongoose.h: * - MG_EV_MQTT_PUBREC
mongoose.h: * - MG_EV_MQTT_PUBREL
mongoose.h: * - MG_EV_MQTT_PUBCOMP
mongoose.h: * - MG_EV_MQTT_SUBACK
mongoose.h: * Returns the pos of the next topic expression or -1 when the list
mongoose.h: * NULL-terminated string.
mongoose.h: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.h: * nc->user_data = &brk;
mongoose.h:#define MG_DNS_MESSAGE 100 /* High-level DNS message event */
mongoose.h: *  - A:     struct in_addr *ina
mongoose.h: *  - AAAA:  struct in6_addr *ina
mongoose.h: *  - CNAME: char buffer
mongoose.h: * Returns -1 on error.
mongoose.h: * Returns the number of bytes appended or -1 in case of error.
mongoose.h:/* Low-level: parses a DNS response. */
mongoose.h: * Attaches a built-in DNS event handler to the given listening connection.
mongoose.h: * Disabled by default; enable with `-DMG_ENABLE_DNS_SERVER`.
mongoose.h: * reply = mg_dns_create_reply(&nc->send_mbuf, msg);
mongoose.h: * for (i = 0; i < msg->num_questions; i++) {
mongoose.h: *   rr = &msg->questions[i];
mongoose.h: *   if (rr->rtype == MG_DNS_A_RECORD) {
mongoose.h: * Returns -1 on error.
mongoose.h: * `r->message`.
mongoose.h:  int accept_literal; /* pseudo-resolve literal ipv4 and ipv6 addrs */
mongoose.h: * ----
mongoose.h: * ----
mongoose.h: * Returns 0 on success, -1 on failure.
mongoose.h: * This software is dual-licensed: you can redistribute it and/or modify
mongoose.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
mongoose.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
mongoose.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
mongoose.h:/* Sets CoAP protocol handler - triggers CoAP specific events. */
mongoose.h: * - `#define MG_COAP_ERROR 0x10000`
mongoose.h: * - `#define MG_COAP_FORMAT_ERROR (MG_COAP_ERROR | 0x20000)`
mongoose.h: * - `#define MG_COAP_IGNORE (MG_COAP_ERROR | 0x40000)`
mongoose.h: * - `#define MG_COAP_NOT_ENOUGH_DATA (MG_COAP_ERROR | 0x80000)`
mongoose.h: * - `#define MG_COAP_NETWORK_ERROR (MG_COAP_ERROR | 0x100000)`
mongoose.h: * Parses CoAP message and fills mg_coap_message and returns cm->flags.
mongoose.h: * - in case of UDP COAP_NOT_ENOUGH_DATA means COAP_FORMAT_ERROR,
mongoose.h: * - in case of TCP client can try to receive more data
mongoose.h:  MG_SOCKS_HANDSHAKE_NOAUTH = 0,     /* Handshake method - no authentication */
mongoose.h:  MG_SOCKS_HANDSHAKE_GSSAPI = 1,     /* Handshake method - GSSAPI auth */
mongoose.h:  MG_SOCKS_HANDSHAKE_USERPASS = 2,   /* Handshake method - user/password auth */
mongoose.h:  MG_SOCKS_HANDSHAKE_FAILURE = 0xff, /* Handshake method - failure */
Binary file mongoose.o matches
net_services.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
net_services.c:  return nc->flags & MG_F_IS_WEBSOCKET;
net_services.c:  return nc->flags & MG_F_USER_1;
net_services.c:  nc->flags |= MG_F_USER_1; 
net_services.c:  for (c = mg_next(nc->mgr, NULL); c != NULL; c = mg_next(nc->mgr, c)) {
net_services.c:      start_mqtt(nc->mgr);
net_services.c:  for (c = mg_next(nc->mgr, NULL); c != NULL; c = mg_next(nc->mgr, c)) {
net_services.c:  return (int)((fahrenheit - 32) * 5 / 9)+0.5f;
net_services.c:  send_mqtt(nc, _aqualink_config->mqtt_dz_pub_topic, mqtt_msg);
net_services.c:  send_mqtt(nc, _aqualink_config->mqtt_dz_pub_topic, mqtt_msg);
net_services.c:  sprintf(mqtt_pub_topic, "%s/%s",_aqualink_config->mqtt_aq_topic, dev_name);
net_services.c:  sprintf(degC, "%.2f", (_aqualink_data->temp_units==FAHRENHEIT)?degFtoC(value):value );
net_services.c:  sprintf(mqtt_pub_topic, "%s/%s", _aqualink_config->mqtt_aq_topic, dev_name);
net_services.c:  sprintf(degC, "%.2f", (_aqualink_data->temp_units==FAHRENHEIT)?degFtoC(value):value );
net_services.c:  sprintf(mqtt_pub_topic, "%s/%s/setpoint", _aqualink_config->mqtt_aq_topic, dev_name);
net_services.c:  if (_aqualink_data->air_temp != TEMP_UNKNOWN && _aqualink_data->air_temp != _last_mqtt_aqualinkdata.air_temp) {
net_services.c:    _last_mqtt_aqualinkdata.air_temp = _aqualink_data->air_temp;
net_services.c:    send_mqtt_temp_msg(nc, "Temperature/Air", _aqualink_data->air_temp);
net_services.c:    send_domoticz_mqtt_msg(nc, _aqualink_config->dzidx_air_temp, (_aqualink_data->temp_units==FAHRENHEIT)?degFtoC(_aqualink_data->air_temp):_aqualink_data->air_temp);
net_services.c:  if (_aqualink_data->pool_temp != TEMP_UNKNOWN && _aqualink_data->pool_temp != _last_mqtt_aqualinkdata.pool_temp) {
net_services.c:    _last_mqtt_aqualinkdata.pool_temp = _aqualink_data->pool_temp;
net_services.c:    send_mqtt_temp_msg(nc, "Temperature/Pool", _aqualink_data->pool_temp);
net_services.c:    send_domoticz_mqtt_msg(nc, _aqualink_config->dzidx_pool_water_temp, (_aqualink_data->temp_units==FAHRENHEIT)?degFtoC(_aqualink_data->pool_temp):_aqualink_data->pool_temp);
net_services.c:  if (_aqualink_data->spa_temp != TEMP_UNKNOWN && _aqualink_data->spa_temp != _last_mqtt_aqualinkdata.spa_temp) {
net_services.c:    _last_mqtt_aqualinkdata.spa_temp = _aqualink_data->spa_temp;
net_services.c:    send_mqtt_temp_msg(nc, "Temperature/Spa", _aqualink_data->spa_temp);
net_services.c:    send_domoticz_mqtt_msg(nc, _aqualink_config->dzidx_spa_water_temp, (_aqualink_data->temp_units==FAHRENHEIT)?degFtoC(_aqualink_data->spa_temp):_aqualink_data->pool_temp);
net_services.c:  if (_aqualink_data->pool_htr_set_point != TEMP_UNKNOWN && _aqualink_data->pool_htr_set_point != _last_mqtt_aqualinkdata.pool_htr_set_point) {
net_services.c:    _last_mqtt_aqualinkdata.pool_htr_set_point = _aqualink_data->pool_htr_set_point;
net_services.c:    send_mqtt_setpoint_msg(nc, BTN_POOL_HTR, _aqualink_data->pool_htr_set_point);
net_services.c:    //send_domoticz_mqtt_msg_setpoint(nc, _aqualink_config->dzidx_pool_thermostat, 0, degFtoC(_aqualink_data->pool_htr_set_point));
net_services.c:  if (_aqualink_data->spa_htr_set_point != TEMP_UNKNOWN && _aqualink_data->spa_htr_set_point != _last_mqtt_aqualinkdata.spa_htr_set_point) {
net_services.c:    _last_mqtt_aqualinkdata.spa_htr_set_point = _aqualink_data->spa_htr_set_point;
net_services.c:    send_mqtt_setpoint_msg(nc, BTN_SPA_HTR, _aqualink_data->spa_htr_set_point);
net_services.c:    //send_domoticz_mqtt_msg_setpoint(nc, _aqualink_config->dzidx_spa_thermostat, 0, degFtoC(_aqualink_data->spa_htr_set_point));
net_services.c://if (time(NULL) % 2) {}   <-- use to determin odd/even second in time to make state flash on enabled.
net_services.c:    //logMessage(LOG_INFO, "LED %d : new state %d | old state %d\n", i, _aqualink_data->aqbuttons[i].led->state, _last_mqtt_aqualinkdata.aqualinkleds[i].state);
net_services.c:    if (_last_mqtt_aqualinkdata.aqualinkleds[i].state != _aqualink_data->aqbuttons[i].led->state){
net_services.c:      _last_mqtt_aqualinkdata.aqualinkleds[i].state = _aqualink_data->aqbuttons[i].led->state;
net_services.c:      if (_aqualink_data->aqbuttons[i].dz_idx != DZ_NULL_IDX) {
net_services.c:        send_mqtt_state_msg(nc, _aqualink_data->aqbuttons[i].name, _aqualink_data->aqbuttons[i].led->state);
net_services.c:        send_domoticz_mqtt_msg(nc, _aqualink_data->aqbuttons[i].dz_idx, (_aqualink_data->aqbuttons[i].led->state==OFF?DZ_OFF:DZ_ON));
net_services.c:  if (_aqualink_data->air_temp != TEMP_UNKNOWN)
net_services.c:    length += sprintf(buffer+length, "t0 %d\n",(int)degFtoC(_aqualink_data->air_temp)*10);
net_services.c:  if (_aqualink_data->pool_temp != TEMP_UNKNOWN)
net_services.c:    length += sprintf(buffer+length, "t1 %d\n",(int)degFtoC(_aqualink_data->pool_temp)*10);
net_services.c:  sprintf(buf, "%-5s%-5d%.2f",value, 5, _aqualink_config->light_programming_mode );
net_services.c:    char *uri = (char *)malloc(http_msg->uri.len + http_msg->query_string.len + 2);
net_services.c:    strncpy(uri, http_msg->uri.p, http_msg->uri.len + http_msg->query_string.len + 1);
net_services.c:    uri[http_msg->uri.len + http_msg->query_string.len + 1] = '\0';
net_services.c:  if (strstr(http_msg->method.p, "GET") && http_msg->query_string.len > 0) {
net_services.c:    mg_get_http_var(&http_msg->query_string, "command", command, sizeof(command));
net_services.c:    // if (strstr(http_msg->query_string.p, "command=status")) {
net_services.c:      mg_send_head(nc, 200, size, "Content-Type: application/json");
net_services.c:      //} else if (strstr(http_msg->query_string.p, "command=mhstatus")) {
net_services.c:      mg_send_head(nc, 200, size, "Content-Type: text/plain");
net_services.c:      mg_get_http_var(&http_msg->query_string, "value", value, sizeof(value));
net_services.c:      mg_send_head(nc, 200, strlen(GET_RTN_OK), "Content-Type: text/plain");
net_services.c:        if (strcmp(command, _aqualink_data->aqbuttons[i].name) == 0) {
net_services.c:          mg_get_http_var(&http_msg->query_string, "value", value, sizeof(value));
net_services.c:          // *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c:            if (_aqualink_data->aqbuttons[i].led->state == OFF || _aqualink_data->aqbuttons[i].led->state == FLASH) {
net_services.c:              aq_programmer(AQ_SEND_CMD, (char *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c:              logMessage(LOG_INFO, "WEB: '%s' is already on '%s', current state %d\n", command, value, _aqualink_data->aqbuttons[i].led->state);
net_services.c:            if (_aqualink_data->aqbuttons[i].led->state == ON || 
net_services.c:                _aqualink_data->aqbuttons[i].led->state == ENABLE ||
net_services.c:                _aqualink_data->aqbuttons[i].led->state == FLASH) {
net_services.c:              aq_programmer(AQ_SEND_CMD, (char *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c:              logMessage(LOG_INFO, "WEB: '%s' is already off '%s', current state %d\n", command, value, _aqualink_data->aqbuttons[i].led->state);
net_services.c:            aq_programmer(AQ_SEND_CMD, (char *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c:          mg_send_head(nc, 200, strlen(rtn), "Content-Type: text/plain");
net_services.c:    mg_send_head(nc, 200, sizeof(GET_RTN_UNKNOWN), "Content-Type: text/plain");
net_services.c:  strncpy(buffer, (char *)wm->data, wm->size);
net_services.c:  buffer[wm->size] = '\0';
net_services.c:  logMessage(LOG_INFO, "WS: Message - Key '%s' Value '%s' | Key2 '%s' Value2 '%s'\n", request.first.key, request.first.value, request.second.key,
net_services.c:        if (strcmp(request.first.value, _aqualink_data->aqbuttons[i].name) == 0) {
net_services.c:          logMessage (LOG_INFO, "WS: button '%s' pressed\n",_aqualink_data->aqbuttons[i].name);
net_services.c:          // send_command( (unsigned char)_aqualink_data->aqbuttons[i].code);
net_services.c:          aq_programmer(AQ_SEND_CMD, (char *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c://printf("Topic %.*s\n",msg->topic.len, msg->topic.p);
net_services.c:  char *pt1 = (char *)&msg->topic.p[strlen(_aqualink_config->mqtt_aq_topic)+1];
net_services.c:  for (i=10; i < msg->topic.len; i++) {
net_services.c:    if ( msg->topic.p[i] == '/' ) {
net_services.c:        pt2 = (char *)&msg->topic.p[++i];
net_services.c:        pt3 = (char *)&msg->topic.p[++i];
net_services.c:      if (strncmp(pt1, _aqualink_data->aqbuttons[i].name, strlen(_aqualink_data->aqbuttons[i].name)) == 0 ){
net_services.c:        logMessage(LOG_INFO, "MQTT: MATCH %s to topic %.*s\n",_aqualink_data->aqbuttons[i].name,msg->topic.len, msg->topic.p);
net_services.c:      if (strncmp(pt1, _aqualink_data->aqbuttons[i].name, strlen(_aqualink_data->aqbuttons[i].name)) == 0 ){
net_services.c:        logMessage(LOG_INFO, "MQTT: MATCH %s to topic %.*s\n",_aqualink_data->aqbuttons[i].name,msg->topic.len, msg->topic.p);
net_services.c:        int status = atoi(msg->payload.p);
net_services.c:          logMessage(LOG_INFO, "MQTT: received unknown status of '%.*s' for '%s', Ignoring!\n", msg->payload.len, msg->payload.p, status, _aqualink_data->aqbuttons[i].name);
net_services.c:        else if ( (_aqualink_data->aqbuttons[i].led->state == OFF && status==0) ||
net_services.c:           (status == 1 && (_aqualink_data->aqbuttons[i].led->state == ON || 
net_services.c:                                _aqualink_data->aqbuttons[i].led->state == FLASH || 
net_services.c:                                _aqualink_data->aqbuttons[i].led->state == ENABLE))) {
net_services.c:          logMessage(LOG_INFO, "MQTT: received '%s' for '%s', already '%s', Ignoring\n", (status==0?"OFF":"ON"), _aqualink_data->aqbuttons[i].name, (status==0?"OFF":"ON"));
net_services.c:          logMessage(LOG_INFO, "MQTT: received '%s' for '%s', turning '%s'\n", (status==0?"OFF":"ON"), _aqualink_data->aqbuttons[i].name,(status==0?"OFF":"ON"));
net_services.c:          aq_programmer(AQ_SEND_CMD, (char *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c:    logMessage(LOG_INFO, "MQTT: ignoring topic %.*s\n",msg->topic.len, msg->topic.p);
net_services.c:  int idx = -1;
net_services.c:  int nvalue = -1;
net_services.c:  if (parseJSONmqttrequest(msg->payload.p, msg->payload.len, &idx, &nvalue, svalue)) {
net_services.c:      if (_aqualink_data->aqbuttons[i].dz_idx == idx){
net_services.c:        if ( (_aqualink_data->aqbuttons[i].led->state == OFF && nvalue==DZ_OFF) ||
net_services.c:           (nvalue == DZ_ON && (_aqualink_data->aqbuttons[i].led->state == ON || 
net_services.c:                                _aqualink_data->aqbuttons[i].led->state == FLASH || 
net_services.c:                                _aqualink_data->aqbuttons[i].led->state == ENABLE))) {
net_services.c:          logMessage(LOG_INFO, "MQTT: DZ: received '%s' for '%s', already '%s', Ignoring\n", (nvalue==DZ_OFF?"OFF":"ON"), _aqualink_data->aqbuttons[i].name, (nvalue==DZ_OFF?"OFF":"ON"));
net_services.c:          if (_aqualink_data->active_thread.ptype == AQ_SET_COLORMODE ) {
net_services.c:            logMessage(LOG_NOTICE, "MQTT: DZ: received '%s' for '%s', IGNORING as we are programming light mode\n", (nvalue==DZ_OFF?"OFF":"ON"), _aqualink_data->aqbuttons[i].name);
net_services.c:            logMessage(LOG_INFO, "MQTT: DZ: received '%s' for '%s', turning '%s'\n", (nvalue==DZ_OFF?"OFF":"ON"), _aqualink_data->aqbuttons[i].name,(nvalue==DZ_OFF?"OFF":"ON"));
net_services.c:            aq_programmer(AQ_SEND_CMD, (char *)&_aqualink_data->aqbuttons[i].code, _aqualink_data);
net_services.c:    if (idx == _aqualink_config->dzidx_pool_thermostat) {
net_services.c:      if (degC > 0.0 && 1 < (degF - _aqualink_data->pool_htr_set_point)) {
net_services.c:        logMessage(LOG_INFO, "MQTT: DZ: received temp setting '%s' for 'pool heater setpoint' old value %d(f) setting to %f(c) %d(f)\n",svalue, _aqualink_data->pool_htr_set_point, degC, degF);
net_services.c:    } else if (idx == _aqualink_config->dzidx_spa_thermostat) {
net_services.c:      if (degC > 0.0 && 1 < (degF - _aqualink_data->spa_htr_set_point)) {
net_services.c:        logMessage(LOG_INFO, "MQTT: DZ: received temp setting '%s' for 'spa heater setpoint' old value %d(f) setting to %f(c) %d(f)\n",svalue, _aqualink_data->spa_htr_set_point, degC, degF);
net_services.c:    //nc->user_data = WEB;
net_services.c:    //nc->user_data = WS;
net_services.c:      logMessage(LOG_DEBUG, "-- Websocket left\n");
net_services.c:    //nc->user_data = MQTT;
net_services.c:    //nc->flags |= MG_F_USER_1; // NFS Need to readup on this
net_services.c:    opts.user_name = _aqualink_config->mqtt_user;
net_services.c:    opts.password = _aqualink_config->mqtt_passwd;
net_services.c:    mg_send_mqtt_handshake_opt(nc, _aqualink_config->mqtt_ID, opts);
net_services.c:    logMessage(LOG_INFO, "MQTT: Subscribing mqtt with id of: %s\n", _aqualink_config->mqtt_ID);
net_services.c:      if (mqtt_msg->connack_ret_code != MG_EV_MQTT_CONNACK_ACCEPTED) {
net_services.c:        logMessage(LOG_WARNING, "Got mqtt connection error: %d\n", mqtt_msg->connack_ret_code);
net_services.c:      snprintf(aq_topic, 29, "%s/#", _aqualink_config->mqtt_aq_topic);
net_services.c:      if (_aqualink_config->mqtt_aq_topic != NULL && _aqualink_config->mqtt_dz_sub_topic != NULL) {
net_services.c:        topics[1].topic = _aqualink_config->mqtt_dz_sub_topic;
net_services.c:        logMessage(LOG_INFO, "MQTT: Subscribing to '%s'\n", _aqualink_config->mqtt_dz_sub_topic);
net_services.c:      else if (_aqualink_config->mqtt_aq_topic != NULL) {
net_services.c:      else if (_aqualink_config->mqtt_aq_topic != NULL) {
net_services.c:        topics[0].topic = _aqualink_config->mqtt_dz_sub_topic;;
net_services.c:        logMessage(LOG_INFO, "MQTT: Subscribing to '%s'\n", _aqualink_config->mqtt_dz_sub_topic);
net_services.c:    logMessage(LOG_INFO, "MQTT: Message publishing acknowledged (msg_id: %d)\n", mqtt_msg->message_id);
net_services.c:    if (mqtt_msg->message_id != 0) {
net_services.c:      logMessage(LOG_INFO, "MQTT: received (msg_id: %d), looks like my own message, ignoring\n", mqtt_msg->message_id);
net_services.c:    if (strncmp(mqtt_msg->topic.p, _aqualink_config->mqtt_aq_topic, strlen(_aqualink_config->mqtt_aq_topic)) == 0) {
net_services.c:    if (strncmp(mqtt_msg->topic.p, _aqualink_config->mqtt_dz_sub_topic, strlen(_aqualink_config->mqtt_dz_sub_topic)) == 0) {
net_services.c:    struct mg_mqtt_proto_data *pd = (struct mg_mqtt_proto_data *)nc->proto_data;
net_services.c:    if (pd->keep_alive > 0 && last_control_time > 0 && (now - last_control_time) > pd->keep_alive) {
net_services.c:  logMessage (LOG_NOTICE, "Starting MQTT client to %s\n", _aqualink_config->mqtt_server);
net_services.c:  if (mg_connect(mgr, _aqualink_config->mqtt_server, ev_handler) == NULL) {
net_services.c:      logMessage (LOG_ERR, "Failed to create MQTT listener to %s\n", _aqualink_config->mqtt_server);
net_services.c:  logMessage (LOG_NOTICE, "Starting web server on port %s\n", _aqualink_config->socket_port);
net_services.c:  nc = mg_bind(mgr, _aqualink_config->socket_port, ev_handler);
net_services.c:  s_http_server_opts.document_root = _aqualink_config->web_directory;  // Serve current directory
Binary file net_services.o matches
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:;TYPE:WALL-INNER
Pi_Zero_Case.gcode:;TYPE:WALL-OUTER
Pi_Zero_Case.gcode:G1 F1800 E-3
README.md:* Test every works :-
README.md:    * `sudo aqualinkd -d -c /etc/aqualinkd.conf`
README.md:### Note:-
README.md:The install script is designed for systemd / systemctl to run as a service or daemon. If you are using init / init-d then don't run the install script, install manuallt and the init-d script to use is in the xtras directory.
README.md:Manual install for init-d systems
README.md:* copy ./extras/aqualinkd.init.d to /etc/init-d/aqualink
README.md:* sudo update-rc.d aqualinkd defaults
README.md:* Only WEB interface (using WS) can change freeze & heater temprature set-points. Need to add support for MQTT and HTTP.
README.md:* Web interface has a lot of fixed layout items that as specific to my implimentation. The HTML & CSS need a complete overhall and re-though to support different configurations.
README.md:You will need a [USB2RS485](https://www.amazon.com/OctagonStar-Converter-Adapter-Interface-FT232RL/dp/B01LCFRR3E/) adapter connected to your pool equiptmeent RS buss interface.  (If you have an inside controller mounted on your wall, this is usually best place, if not the outside control panel is the next best place).  Then a computer running linux connected to that USB2RS485 adapter. Code is designed & developed for raspberry pi zero w, so any computer with that as a minimum should work.
README.md:* Install a MQTT broker (mosquitto) is recomended, this can usually be installed with apt-get
README.md:You can of course use a myriad of other HomeKit bridges with the URL endpoints listed in the `All other hubs section`, or MQTT topics listed in the `MQTT` section. The majority of them (including HomeBridge the most popular) use Node and HAP-Node.JS, neither of which I am a fan of for the RaspberryPI. But HomeKit2MQTT seemed to have the least overhead of them all. So that's why the recomendation.
README.md:To use.  copy the `meteohub-aq-plugin.sh` script from the extras directory to your meteohub box, edit the script and use your IP address in the line that makes the URL call, below.
README.md:wget -O /dev/stdout 'http://your.ip.address.here/?command=mhstatus' 2>/dev/null
README.md:In meteohub create a new weatherstation plug-in, plug-in path is the path to the above sctipt, and his save.  2 new sensors should now show up as thermo in the sensor page.
utils.c: * Copyright (c) 2017 Shaun Feakes - All rights reserved
utils.c:static int _log_level = -1;
utils.c:From -- syslog.h --
utils.c:#define	LOG_DEBUG	7	// debug-level messages 
utils.c:    strftime(time_string, TIMESTAMP_LENGTH, "%b-%d-%y %H:%M:%S %p ", tmptr);
utils.c:  end = str + strlen(str) - 1;
utils.c:  while(end > str && isspace(*end)) end--;
utils.c:  end = str + strlen(str) - 1;
utils.c:  while(end > str && isspace(*end)) end--;
utils.c:  end = str + strlen(str) - 1;
utils.c:  while(end > str && (*end=='"' || *end== '\'' || *end==' ')) end--;
utils.c:  sprintf(buffer,"Level %d | MsgLvl %d | Dmn %d | LF %d | %s - %s",_log_level,msg_level,_daemonise,_log2file,_log_filename,msg);
utils.c:  if ( buffer[strlen(buffer)-1] != '\n') {
utils.c:  if (fp != -1) {
utils.c:  if (_log_level == -1) {
utils.c:    //printf( " '%s' last chrs '%d''%d'\n", buffer, buffer[len-1],buffer[len]);
utils.c:    if ( buffer[len-1] != '\n') {
utils.c:    if (fp != -1) {
utils.c:// (50F - 32) x .5556 = 10C
utils.c:  return ((degF-32) / 1.8);
Binary file utils.o matches
